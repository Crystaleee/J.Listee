# A0139995E
###### CS2103\src\entity\Command.java
``` java
 */
package entity;
/**
 * The interface which all commands implement.
 */
public interface Command {

	public Display execute(Display display);

    /*
     * Since not all commands require saving to storage,
     * this is used to check if that command requires saving to storage
     */
	public boolean requiresUpdateFile();

    /*
     * Since not all commands require saving to history,
     * this is used to check if that command requires saving to history
     */
	public boolean requiresSaveHistory();
}
```
###### CS2103\src\entity\CommandAddDeadlineTask.java
``` java
 */
package entity;

/**
 * This is the command to add deadline task.
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandAddDeadlineTask implements Command {
    private TaskDeadline _task;
    private boolean _updateFile = true;
    private boolean _saveHistory = true;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandAddDeadlineTask() {
        _task = null;
    }

    public CommandAddDeadlineTask(TaskDeadline task) {
        this._task = task;
    }

    public CommandAddDeadlineTask(String description, String location, Calendar endDate,
            ArrayList<String> tags) {
        _task = new TaskDeadline(description, location, endDate, tags);
    }

    public Display execute(Display display) {
        assert display != null: "AddDeadline: null display";
        if (hasNoDescription()) {
            _logger.log(Level.INFO, "AddDeadline: No desc");
            setInvalidDisplay(display);
            return display;
        }
        addDeadlineTask(display.getDeadlineTasks());
        if (!display.getVisibleDeadlineTasks().equals(display.getDeadlineTasks())) {
            addDeadlineTask(display.getVisibleDeadlineTasks());
        }
        setDisplay(display);

        return display;
    }

    private boolean hasNoDescription() {
        if (_task.getDescription() == null) {
            return true;
        } else {
            _task.setDescription(_task.getDescription().trim());
            if (_task.getDescription().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay(Display display) {
        _updateFile = false;
        _saveHistory = false;
        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        display.setMessage(GlobalConstants.MESSAGE_ERROR_DESCRIPTION);
    }

    private void setDisplay(Display display) {
        ArrayList<Integer> taskIndices = new ArrayList<Integer>();
        display.setCommandType(GlobalConstants.GUI_ANIMATION_ADD);
        taskIndices.add(display.getVisibleDeadlineTasks().indexOf(_task) + 1);
        display.setTaskIndices(taskIndices);
        display.setMessage(String.format(GlobalConstants.MESSAGE_ADD_SUCCESS, _task.getDescription()));
        display.setConflictingTasksIndices(new ArrayList<Integer>());
        setIfOverdue();
    }

    private void setIfOverdue() {
        if (_task.getEndDate().before(Calendar.getInstance())) {
            _task.setIsOverdue(true);
        }
    }

    private void addDeadlineTask(ArrayList<TaskDeadline> taskList) {
        int index = getIndex(taskList);
        taskList.add(index, _task);
    }

    /**
     * This method searches for the index to slot the deadline task in since we
     * are sorting the list in order of earliest deadline first
     */
    private int getIndex(ArrayList<TaskDeadline> taskList) {
        int i = 0;
        for (i = 0; i < taskList.size(); i++) {
            if (_task.getEndDate().compareTo(taskList.get(i).getEndDate()) < 0) {
                break;
            }
        }
        return i;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandAddEvent.java
``` java
 */
package entity;
/**
 * This command is to add an event task.
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandAddEvent implements Command {
    private TaskEvent _task;
    private boolean _updateFile = true;
    private boolean _saveHistory = true;
    private ArrayList<Integer> _conflictingTasksIndices = new ArrayList<Integer>();
    private Logger _logger = GlobalLogger.getLogger();

    public CommandAddEvent() {
        _task = null;
    }

    public CommandAddEvent(TaskEvent task) {
        this._task = task;
    }

    public CommandAddEvent(String description, String location, Calendar startDate, Calendar endDate,
            ArrayList<String> tags) {
        _task = new TaskEvent(description, location, startDate, endDate, tags);
    }

    public Display execute(Display display) {
        assert display != null: "AddEvent: null display";
        
        if (hasNoDescription()) {
            _logger.log(Level.INFO, "AddEvent: No desc");
            setInvalidDisplay(display, GlobalConstants.MESSAGE_ERROR_DESCRIPTION);
            return display;
        }
        if (isInvalidTimeRange()) {
            _logger.log(Level.INFO, "AddEvent: Invalid time");
            setInvalidDisplay(display, GlobalConstants.MESSAGE_ERROR_DATE_RANGE);
            return display;
        }
        addEvent(display.getEventTasks());
        if (!display.getVisibleEvents().equals(display.getEventTasks())) {
            addEvent(display.getVisibleEvents());
        }
        setDisplay(display);
        return display;
    }

    private boolean isInvalidTimeRange() {
        return _task.getStartDate().after(_task.getEndDate());
    }

    private boolean hasNoDescription() {
        if (_task.getDescription() == null) {
            return true;
        } else {
            _task.setDescription(_task.getDescription().trim());
            if (_task.getDescription().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay(Display display, String msg) {
        _updateFile = false;
        _saveHistory = false;
        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        display.setMessage(msg);
    }

    private void setDisplay(Display display) {
        ArrayList<Integer> taskIndices = new ArrayList<Integer>();
        display.setCommandType(GlobalConstants.GUI_ANIMATION_ADD);
        int index = getAddedTaskIndex(display);
        taskIndices.add(index);
        display.setTaskIndices(taskIndices);
        display.setMessage(String.format(GlobalConstants.MESSAGE_ADD_SUCCESS, _task.getDescription()));
        getConflictingTasks(display);
        setIfOverdue();
    }

    private void setIfOverdue() {
        if(_task.getEndDate().before(Calendar.getInstance())){
            _task.setIsOverdue(true);
        }
    }

    private void getConflictingTasks(Display display) {
        getConflictingEvents(display);
        getConflictingReservedTasks(display);
        display.setConflictingTasksIndices(_conflictingTasksIndices);
    }


    /**
     * This method searches for conflicting reserved tasks
     */
    private void getConflictingReservedTasks(Display display) {
        ArrayList<TaskReserved> listReserved = display.getReservedTasks();
        for (TaskReserved myTask : listReserved) {
            for (int i = 0; i < myTask.getStartDates().size(); i++) {
                if (isWithinTimeRange(_task.getStartDate(), _task.getEndDate(), myTask.getStartDates().get(i),
                        myTask.getEndDates().get(i))) {
                    int index = display.getVisibleReservedTasks().indexOf(myTask);
                    if (isValidIndex(index)) {
                        index = getConflictingTaskReservedIndex(display, index);
                        _conflictingTasksIndices.add(index);
                    }
                    break;
                }
            }
        }
    }

    private int getConflictingTaskReservedIndex(Display display, int index) {
        return index + display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
                + display.getVisibleFloatTasks().size() + 1;
    }

    private boolean isValidIndex(int index) {
        return index >= 0;
    }
    
    /**
     * This method searches for conflicting events
     */
    private void getConflictingEvents(Display display) {
        ArrayList<TaskEvent> listEvents = display.getEventTasks();
        for (TaskEvent myTask : listEvents) {
            if (!myTask.equals(_task)) {
                if (isWithinTimeRange(_task.getStartDate(), _task.getEndDate(), myTask.getStartDate(),
                        myTask.getEndDate())) {
                    int index = display.getVisibleEvents().indexOf(myTask);
                    if (isValidIndex(index)) {
                        index = getConflictingTaskEventIndex(display, index);
                        _conflictingTasksIndices.add(index);
                    }
                }
            }
        }
    }

    private int getConflictingTaskEventIndex(Display display, int index) {
        return index + display.getVisibleDeadlineTasks().size() + 1;
    }

    private boolean isWithinTimeRange(Calendar start, Calendar end, Calendar rangeStart, Calendar rangeEnd) {
        if (!start.before(rangeStart)) {
            if (!start.after(rangeEnd)) {
                return true;
            }
        } else if (!end.before(rangeStart)) {
            return true;
        }
        return false;
    }

    private int getAddedTaskIndex(Display display) {
        return display.getVisibleEvents().indexOf(_task) + display.getVisibleDeadlineTasks().size() + 1;
    }

    private void addEvent(ArrayList<TaskEvent> taskList) {
        int index = getAddIndex(taskList);
        taskList.add(index, _task);
    }

    /**
     * This method searches for the index to slot the deadline task in since we
     * are sorting the list in order of earliest start time first
     */
    private int getAddIndex(ArrayList<TaskEvent> taskList) {
        int i = 0;
        for (i = 0; i < taskList.size(); i++) {
            if (_task.getStartDate().compareTo(taskList.get(i).getStartDate()) < 0) {
                break;
            }
        }
        return i;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandAddFloatTask.java
``` java
 */
package entity;

/**
 * This command is to add a floating task.
 */
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandAddFloatTask implements Command {
    private TaskFloat _task;
    private boolean _updateFile = true;
    private boolean _saveHistory = true;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandAddFloatTask() {
        _task = null;
    }

    public CommandAddFloatTask(TaskFloat task) {
        this._task = task;
    }

    public CommandAddFloatTask(String description, String location, ArrayList<String> tags) {
        _task = new TaskFloat(description, location, tags);
    }

    public Display execute(Display display) {
        assert display != null: "AddFloat: null display";
        if (hasNoDescription()) {
            _logger.log(Level.INFO, "AddFloat: No desc");
            setInvalidDisplay(display);
            return display;
        }
        display.getFloatTasks().add(_task);
        if (!display.getVisibleFloatTasks().equals(display.getFloatTasks())) {
            display.getVisibleFloatTasks().add(_task);
        }
        setDisplay(display);
        return display;
    }

    private boolean hasNoDescription() {
        if (_task.getDescription() == null) {
            return true;
        } else {
            _task.setDescription(_task.getDescription().trim());
            if (_task.getDescription().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay(Display display) {
        _updateFile = false;
        _saveHistory = false;
        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        display.setMessage(GlobalConstants.MESSAGE_ERROR_DESCRIPTION);
    }

    private void setDisplay(Display display) {
        ArrayList<Integer> taskIndices = new ArrayList<Integer>();
        display.setCommandType(GlobalConstants.GUI_ANIMATION_ADD);
        int index = display.getVisibleFloatTasks().indexOf(_task) + display.getVisibleEvents().size()
                + display.getVisibleDeadlineTasks().size() + 1;
        taskIndices.add(index);
        display.setTaskIndices(taskIndices);
        display.setMessage(String.format(GlobalConstants.MESSAGE_ADD_SUCCESS, _task.getDescription()));
        display.setConflictingTasksIndices(new ArrayList<Integer>());
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandAddReserved.java
``` java
 */
package entity;
/**
 * This command is to add a reserved task.
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandAddReserved implements Command {
    private TaskReserved _task;
    private boolean _updateFile = true;
    private boolean _saveHistory = true;
    private ArrayList<Integer> _conflictingTasksIndices = new ArrayList<Integer>();
    private Logger _logger = GlobalLogger.getLogger();

    public CommandAddReserved() {
        _task = null;
    }

    public CommandAddReserved(TaskReserved task) {
        this._task = task;
    }

    public CommandAddReserved(String description, String location, ArrayList<Calendar> startDates,
            ArrayList<Calendar> endDates, ArrayList<String> tags) {
        _task = new TaskReserved(description, location, startDates, endDates, tags);
    }

    public Display execute(Display display) {
        assert display != null: "AddReserved: null display";
        if (hasNoDescription()) {
            _logger.log(Level.INFO, "AddReserved: No desc");
            setInvalidDisplay(display, GlobalConstants.MESSAGE_ERROR_DESCRIPTION);
            return display;
        }
        if (containsInvalidTimeSlots()) {
            _logger.log(Level.INFO, "AddReserved: Invalid time");
            setInvalidDisplay(display, GlobalConstants.MESSAGE_ERROR_TIME_RANGE);
            return display;
        }
        display.getReservedTasks().add(_task);
        if (!display.getVisibleReservedTasks().equals(display.getReservedTasks())) {
            display.getVisibleReservedTasks().add(_task);
        }
        setDisplay(display);
        return display;
    }

    private boolean hasNoDescription() {
        if (_task.getDescription() == null) {
            return true;
        } else {
            _task.setDescription(_task.getDescription().trim());
            if (_task.getDescription().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay(Display display, String msg) {
        _updateFile = false;
        _saveHistory = false;
        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        display.setMessage(msg);
    }

    private void setDisplay(Display display) {
        ArrayList<Integer> taskIndices = new ArrayList<Integer>();
        display.setCommandType(GlobalConstants.GUI_ANIMATION_ADD);
        int index = display.getVisibleReservedTasks().indexOf(_task)
                + display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
                + display.getVisibleFloatTasks().size() + 1;
        taskIndices.add(index);
        display.setTaskIndices(taskIndices);
        display.setMessage(String.format(GlobalConstants.MESSAGE_RESERVED, _task.getDescription()));
        getConflictingTasks(display);
    }

    private void getConflictingTasks(Display display) {
        getConflictingEvents(display);
        getConflictingReservedTasks(display);
        display.setConflictingTasksIndices(_conflictingTasksIndices);
    }

    /**
     * This method searches for conflicting reserved tasks
     */
    private void getConflictingReservedTasks(Display display) {
        ArrayList<TaskReserved> listReserved = display.getReservedTasks();
        for (TaskReserved myTask : listReserved) {
            checkReservedTask: for (int i = 0; i < myTask.getStartDates().size(); i++) {
                for (int j = 0; j < _task.getStartDates().size(); j++) {
                    if (!myTask.equals(_task)) {
                        if (isWithinTimeRange(_task.getStartDates().get(j), _task.getEndDates().get(j),
                                myTask.getStartDates().get(i), myTask.getEndDates().get(i))) {
                            int index = display.getVisibleReservedTasks().indexOf(myTask);
                            if (isValidIndex(index)) {
                                index = getConflictingTaskReservedIndex(display, index);
                                _conflictingTasksIndices.add(index);
                            }
                            break checkReservedTask;
                        }
                    }
                }
            }
        }
    }

    private int getConflictingTaskReservedIndex(Display display, int index) {
        return index + display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
                + display.getVisibleFloatTasks().size() + 1;
    }

    private boolean isValidIndex(int index) {
        return index >= 0;
    }

    /**
     * This method searches for conflicting events
     */
    private void getConflictingEvents(Display display) {
        ArrayList<TaskEvent> listEvents = display.getEventTasks();
        for (TaskEvent myTask : listEvents) {
            for (int i = 0; i < _task.getStartDates().size(); i++) {
                if (isWithinTimeRange(_task.getStartDates().get(i), _task.getEndDates().get(i),
                        myTask.getStartDate(), myTask.getEndDate())) {
                    int index = display.getVisibleEvents().indexOf(myTask);
                    if (isValidIndex(index)) {
                        index = getConflictingTaskEventIndex(display, index);
                        _conflictingTasksIndices.add(index);
                    }
                    break;
                }
            }
        }
    }

    private int getConflictingTaskEventIndex(Display display, int index) {
        return index + display.getVisibleDeadlineTasks().size() + 1;
    }

    private boolean isWithinTimeRange(Calendar start, Calendar end, Calendar rangeStart, Calendar rangeEnd) {
        if (!start.before(rangeStart)) {
            if (!start.after(rangeEnd)) {
                return true;
            }
        } else if (!end.before(rangeStart)) {
            return true;
        }
        return false;
    }
    
    private boolean containsInvalidTimeSlots() {
        if (_task.getStartDates() == null) {
            return true;
        } else if (_task.getEndDates() == null) {
            return true;
        }
        if(_task.getStartDates().size() != _task.getEndDates().size()){
            return true;
        }
        if((_task.getStartDates().isEmpty()) || (_task.getEndDates().isEmpty())){
            return true;
        }
        for (int i = 0; i < _task.getStartDates().size(); i++) {
            if (_task.getStartDates().get(i).after(_task.getEndDates().get(i))) {
                return true;
            }
        }
        return false;
    }
    
    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandConfirm.java
``` java
 */
package entity;
/**
 * This command is to confirm a timeslot of a reserved task
 * and convert it to an event
 */
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandConfirm implements Command {
    private Integer _timeSlotIndex;
    private Integer _taskNumber;
    private TaskReserved _task;
    private String _msg;
    private int _index;
    private boolean _saveHistory = true;
    private boolean _updateFile = true;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandConfirm() {
        this._taskNumber = null;
    }

    public CommandConfirm(Integer taskNumbers, Integer timeSlotIndex) {
        this._taskNumber = taskNumbers;
        this._timeSlotIndex = timeSlotIndex;
    }

    public Display execute(Display display) {
        assert display != null: "Confirm: null display";
        if (hasInvalidParameters(display)) {
            _logger.log(Level.INFO, "Confirm: Invalid Parameters");
            setInvalidDisplay(display);
            return display;
        } else {
            confirmTask(display);
        }
        return display;
    }

    private void confirmTask(Display display) {
        Calendar start = _task.getStartDates().get(_timeSlotIndex);
        Calendar end = _task.getEndDates().get(_timeSlotIndex);
        TaskEvent newTask = new TaskEvent(_task.getDescription(), _task.getLocation(), start, end, _task.getTags());
        Command addEvent = new CommandAddEvent(newTask);
        addEvent.execute(display);
        display.getVisibleReservedTasks().remove(_task);
        display.getReservedTasks().remove(_task);
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay(Display display) {
        _saveHistory = false;
        _updateFile = false;
        display.setTaskIndices(null);
        display.setConflictingTasksIndices(null);
        display.setMessage(_msg);
    }

    /**
     * checks for invalid parameters
     */
    private boolean hasInvalidParameters(Display display) {
        if (display.getReservedTasks().size() == 0) {
            _msg = GlobalConstants.MESSAGE_ERROR_NO_RESERVED_TASKS;
            return true;
        } else if (display.getVisibleReservedTasks().size() == 0) {
            _msg = GlobalConstants.MESSAGE_ERROR_NO_VISIBLE_RESERVED_TASKS;
            return true;
        }
        if (hasNoTaskNumber()) {
            _msg = GlobalConstants.MESSAGE_ERROR_NO_NUMBER;
            return true;
        } else if (isInvalidTaskNumber(display)) {
            _msg = GlobalConstants.MESSAGE_ERROR_INVALID_INDEX;
            return true;
        }
        if (hasNoTimeSlot()) {
            _msg = GlobalConstants.MESSAGE_ERROR_NO_TIMESLOT;
            return true;
        } else if (isInvalidTimeSlot(display)) {
            _msg = GlobalConstants.MESSAGE_ERROR_INVALID_TIMESLOT;
            return true;
        }
        return false;
    }

    private boolean hasNoTimeSlot() {
        return (_timeSlotIndex == null);
    }

    /**
     * checks if the timeslot index specified by user
     * is valid
     */
    private boolean isInvalidTimeSlot(Display display) {
        _index = _taskNumber - display.getVisibleDeadlineTasks().size() - display.getVisibleEvents().size()
                - display.getVisibleFloatTasks().size() - 1;
        _task = display.getVisibleReservedTasks().get(_index);
        _timeSlotIndex--;
        if((_timeSlotIndex < 0) || (_timeSlotIndex >= _task.getStartDates().size())){
            return true;
        }
        return false;
    }

    /**
     * This method will check if the task selected is 
     * a reserved task or if the task number is invalid
     */
    private boolean isInvalidTaskNumber(Display display) {
        int minIndex = display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
                + display.getVisibleFloatTasks().size() + 1;
        int maxIndex = display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
                + display.getVisibleFloatTasks().size() + display.getVisibleReservedTasks().size();
        if ((_taskNumber < minIndex) || (_taskNumber > maxIndex)) {
            return true;
        }
        return false;
    }

    private boolean hasNoTaskNumber() {
        return (_taskNumber == null);
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandDelete.java
``` java
 */
package entity;
/**
 * This command is to delete tasks
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandDelete implements Command {
    private Display _display;
    private ArrayList<Integer> _taskNumbers;
    private boolean _saveHistory = true;
    private boolean _updateFile = true;
    private String _invalidNumbers = "You have specified invalid numbers: ";
    private String _msgDelete = "deleted: ";
    private Logger _logger = GlobalLogger.getLogger();

    public CommandDelete() {
        this._taskNumbers = null;
        this._display = null;
    }

    public CommandDelete(ArrayList<Integer> taskNumbers) {
        this._taskNumbers = taskNumbers;
        this._display = null;
    }

    public Display execute(Display display) {
        assert display != null : "Delete: null display";
        this._display = display;
        if (hasInvalidTaskNumbers()) {
            setInvalidDisplay();
            _logger.log(Level.INFO, "Delete: Index Invalid");
            return _display;
        } else {
            _logger.log(Level.INFO, "Delete: No errors");
            deleteTasksFromList();
        }
        return _display;
    }

    private boolean hasNoTaskNumber() {
        if (_taskNumbers != null) {
            if (_taskNumbers.isEmpty()) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay() {
        _updateFile = false;
        _saveHistory = false;
        _display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        _display.setMessage(_invalidNumbers);
        _display.setTaskIndices(new ArrayList<Integer>());
        _display.setConflictingTasksIndices(new ArrayList<Integer>());
    }

    private void setDisplay(String msg, String commandType, ArrayList<Integer> deletedTasks,
            ArrayList<Integer> conflictingTasks) {
        _display.setMessage(msg);
        _display.setCommandType(commandType);
        _display.setTaskIndices(deletedTasks);
        _display.setConflictingTasksIndices(conflictingTasks);
    }

    private boolean hasInvalidTaskNumbers() {
        if(hasNoTaskNumber()){
            return true;
        }
        if (isDeleteAll()) {
            return false;
        } else {
            ArrayList<Integer> invalidTaskNumbers = getInvalidTaskNumbers();
            return (invalidTaskNumbers.size() > 0);
        }
    }

    private ArrayList<Integer> getInvalidTaskNumbers() {
        ArrayList<Integer> invalidTaskNumbers = new ArrayList<Integer>();
        int taskNum, numOfTasks = getNumOfTasks();
        for (int i = 0; i < _taskNumbers.size(); i++) {
            taskNum = _taskNumbers.get(i);
            if (isTaskNumberInvalid(taskNum, numOfTasks)) {
                feedbackInvalidNumbers(invalidTaskNumbers, taskNum);
                invalidTaskNumbers.add(taskNum);
            }
        }
        return invalidTaskNumbers;
    }

    private int getNumOfTasks() {
        int numOfTasks = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size() + _display.getVisibleReservedTasks().size()
                + _display.getVisibleCompletedTasks().size();
        return numOfTasks;
    }

    private void feedbackInvalidNumbers(ArrayList<Integer> invalidTaskNumbers, int taskNum) {
        if (invalidTaskNumbers.size() == 0) {
            _invalidNumbers += taskNum;
        } else {
            _invalidNumbers += GlobalConstants.COMMA_SPACE + taskNum;
        }
    }

    private boolean isTaskNumberInvalid(int taskNum, int numOfTasks) {
        return (taskNum > numOfTasks) || (taskNum < 1);
    }

    private void deleteTasksFromList() {
        if (isDeleteAll()) {
            deleteAllShownTasks();
            return;
        } else {
            deleteMultipleTasks();
            return;
        }
    }

    /**
     * deletes one/multiple visible tasks
     */
    private void deleteMultipleTasks() {
        Task deletedTask;
        System.out.println(_taskNumbers.get(0));
        Collections.sort(_taskNumbers);
        for (int i = 0; i < _taskNumbers.size(); i++) {
            deletedTask = removeTask(_taskNumbers.get(i) - 1 - i);
            feedbackDeletedTasks(deletedTask, i);
        }
        setDisplay(_msgDelete, GlobalConstants.GUI_ANIMATION_DELETE, _taskNumbers, new ArrayList<Integer>());
    }

    /**
     * deletes all visible tasks
     */
    private void deleteAllShownTasks() {
        int numTasks = getNumOfTasks();
        _taskNumbers = new ArrayList<Integer>();
        for (int i = 0; i < numTasks; i++) {
            removeTask(numTasks - i - 1);
            _taskNumbers.add(i + 1);
        }
        setDisplay(GlobalConstants.MESSAGE_ALL_DELETED, GlobalConstants.GUI_ANIMATION_DELETE, _taskNumbers,
                new ArrayList<Integer>());
    }

    private boolean isDeleteAll() {
        return _taskNumbers == null;
    }

    private void feedbackDeletedTasks(Task deletedTask, int i) {
        if (i == 0) {
            _msgDelete += GlobalConstants.INVERTED_COMMAS + deletedTask.getDescription()
                    + GlobalConstants.INVERTED_COMMAS;
        } else {
            _msgDelete += ", \"" + deletedTask.getDescription() + GlobalConstants.INVERTED_COMMAS;
        }
    }

    private Task removeTask(int taskNum) {
        Task deletedTask;
        if (isDeleteTaskDeadline(taskNum)) {
            deletedTask = deleteTaskDeadline(taskNum);
        } else {
            taskNum -= _display.getVisibleDeadlineTasks().size();
            if (isDeleteTaskEvent(taskNum)) {
                deletedTask = deleteEvent(taskNum);
            } else {
                taskNum -= _display.getVisibleEvents().size();
                if (isDeleteTaskFloat(taskNum)) {
                    deletedTask = deleteTaskFloat(taskNum);
                } else {
                    taskNum -= _display.getVisibleFloatTasks().size();
                    if (isDeleteTaskReserved(taskNum)) {
                        deletedTask = deleteTaskReserved(taskNum);
                    } else {
                        taskNum -= _display.getVisibleReservedTasks().size();
                        deletedTask = deleteTaskCompleted(taskNum);
                    }
                }
            }
        }
        return deletedTask;
    }

    private boolean isDeleteTaskReserved(int taskNum) {
        return taskNum < _display.getVisibleReservedTasks().size();
    }

    private boolean isDeleteTaskFloat(int taskNum) {
        return taskNum < _display.getVisibleFloatTasks().size();
    }

    private boolean isDeleteTaskEvent(int taskNum) {
        return taskNum < _display.getVisibleEvents().size();
    }

    private boolean isDeleteTaskDeadline(int taskNum) {
        return taskNum < _display.getVisibleDeadlineTasks().size();
    }

    private Task deleteTaskCompleted(int taskNum) {
        Task deletedTask = _display.getVisibleCompletedTasks().remove(taskNum);
        _display.getCompletedTasks().remove(deletedTask);
        return deletedTask;
    }

    private Task deleteTaskReserved(int taskNum) {
        Task deletedTask = _display.getVisibleReservedTasks().remove(taskNum);
        _display.getReservedTasks().remove(deletedTask);
        return deletedTask;
    }

    private Task deleteTaskFloat(int taskNum) {
        Task deletedTask = _display.getVisibleFloatTasks().remove(taskNum);
        _display.getFloatTasks().remove(deletedTask);
        return deletedTask;
    }

    private Task deleteEvent(int taskNum) {
        Task deletedTask = _display.getVisibleEvents().remove(taskNum);
        _display.getEventTasks().remove(deletedTask);
        return deletedTask;
    }

    private Task deleteTaskDeadline(int taskNum) {
        Task deletedTask = _display.getVisibleDeadlineTasks().remove(taskNum);
        _display.getDeadlineTasks().remove(deletedTask);
        return deletedTask;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandDone.java
``` java
 */
package entity;

/**
 * This command is to mark a task as completed.
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandDone implements Command {
    private String _msgInvalidNumbers = "You have specified invalid task numbers: ";
    private String _msgComplete = "Completed: ";
    private ArrayList<Integer> _taskNumbers;
    private Display _display;
    private boolean _saveHistory = true;
    private boolean _updateFile = true;
    private Logger logger = GlobalLogger.getLogger();

    public CommandDone() {
        this._taskNumbers = null;
        this._display = null;
    }

    public CommandDone(ArrayList<Integer> taskNumbers) {
        this._taskNumbers = taskNumbers;
        this._display = null;
    }

    public Display execute(Display oldDisplay) {
        assert oldDisplay != null : "Done: null display";
        this._display = oldDisplay;
        if (hasInvalidTaskNumbers()) {
            logger.log(Level.INFO, "Done: Index Invalid");
            setInvalidDisplay();
            return _display;
        } else {
            logger.log(Level.INFO, "Done: No errors");
            doneTasksFromList();
        }
        return _display;
    }

    /**
     * sets variables when the command has invalid parametersS
     */
    private void setInvalidDisplay() {
        _updateFile = false;
        _saveHistory = false;
        _display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        _display.setMessage(_msgInvalidNumbers);
    }

    private void setDisplay(String msg, String commandType, ArrayList<Integer> completedTasks,
            ArrayList<Integer> conflictingTasks) {
        _display.setMessage(msg);
        _display.setCommandType(commandType);
        _display.setTaskIndices(completedTasks);
        _display.setConflictingTasksIndices(conflictingTasks);
    }

    private boolean hasNoTaskNumber() {
        if (_taskNumbers != null) {
            if (_taskNumbers.isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private boolean hasInvalidTaskNumbers() {
        if (hasNoTaskNumber()) {
            return true;
        }
        if (isDoneAll()) {
            return false;
        } else {
            ArrayList<Integer> invalidTaskNumbers = getInvalidTaskNumbers();
            return (invalidTaskNumbers.size() > 0);
        }
    }

    private ArrayList<Integer> getInvalidTaskNumbers() {
        ArrayList<Integer> invalidTaskNumbers = new ArrayList<Integer>();
        int taskNum, numOfTasks = getNumOfTasks();
        for (int i = 0; i < _taskNumbers.size(); i++) {
            taskNum = _taskNumbers.get(i);
            if (isTaskNumberInvalid(taskNum, numOfTasks)) {
                feedbackInvalidNumbers(invalidTaskNumbers, taskNum);
                invalidTaskNumbers.add(taskNum);
            }
        }
        return invalidTaskNumbers;
    }

    private int getNumOfTasks() {
        int numOfTasks = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size();
        return numOfTasks;
    }

    /**
     * sets the feedback for invalid task indices
     */
    private void feedbackInvalidNumbers(ArrayList<Integer> invalidTaskNumbers, int taskNum) {
        if (invalidTaskNumbers.size() == 0) {
            _msgInvalidNumbers += taskNum;
        } else {
            _msgInvalidNumbers += GlobalConstants.COMMA_SPACE + taskNum;
        }
    }

    private boolean isTaskNumberInvalid(int taskNum, int numOfTasks) {
        return (taskNum > numOfTasks) || (taskNum < 1);
    }

    private void doneTasksFromList() {
        if (isDoneAll()) {
            doneAllVisibleTasks();
            return;
        } else {
            doneMultipleTasks();
            return;
        }
    }

    /**
     * Mark one/multiple tasks as done
     */
    private void doneMultipleTasks() {
        Task doneTask;
        Collections.sort(_taskNumbers);
        for (int i = 0; i < _taskNumbers.size(); i++) {
            doneTask = markTaskAsDone(_taskNumbers.get(i) - 1 - i);
            feedbackCompletedTasks(doneTask, i);
        }
        setDisplay(_msgComplete, GlobalConstants.GUI_ANIMATION_DELETE, _taskNumbers,
                new ArrayList<Integer>());
    }

    /**
     * Mark all visible tasks as done
     */
    private void doneAllVisibleTasks() {
        int numTasks = getNumOfTasks();
        _taskNumbers = new ArrayList<Integer>();
        for (int i = 0; i < numTasks; i++) {
            markTaskAsDone(numTasks - i - 1);
            _taskNumbers.add(i + 1);
        }
        setDisplay(GlobalConstants.MESSAGE_ALL_COMPLETED, GlobalConstants.GUI_ANIMATION_DELETE, _taskNumbers,
                new ArrayList<Integer>());
    }

    private boolean isDoneAll() {
        return _taskNumbers == null;
    }

    private void feedbackCompletedTasks(Task doneTask, int i) {
        if (i == 0) {
            _msgComplete += GlobalConstants.INVERTED_COMMAS + doneTask.getDescription()
                    + GlobalConstants.INVERTED_COMMAS;
        } else {
            _msgComplete += GlobalConstants.COMMA_SPACE_INVERTED_COMMAS + doneTask.getDescription()
                    + GlobalConstants.INVERTED_COMMAS;
        }
    }

    private Task markTaskAsDone(int taskNum) {
        Task doneTask;
        if (isTaskDeadline(taskNum)) {
            doneTask = doneTaskDeadline(taskNum);
        } else {
            taskNum -= _display.getVisibleDeadlineTasks().size();
            if (isTaskEvent(taskNum)) {
                doneTask = doneEvent(taskNum);
            } else {
                taskNum -= _display.getVisibleEvents().size();
                doneTask = doneTaskFloat(taskNum);
            }
        }
        return doneTask;
    }

    private boolean isTaskEvent(int taskNum) {
        return taskNum < _display.getVisibleEvents().size();
    }

    private boolean isTaskDeadline(int taskNum) {
        return taskNum < _display.getVisibleDeadlineTasks().size();
    }

    private Task doneTaskFloat(int taskNum) {
        Task completedTask = _display.getVisibleFloatTasks().remove(taskNum);
        _display.getFloatTasks().remove(completedTask);
        _display.getCompletedTasks().add(completedTask);
        return completedTask;
    }

    private Task doneEvent(int taskNum) {
        Task completedTask = _display.getVisibleEvents().remove(taskNum);
        _display.getEventTasks().remove(completedTask);
        _display.getCompletedTasks().add(completedTask);
        return completedTask;
    }

    private Task doneTaskDeadline(int taskNum) {
        Task completedTask = _display.getVisibleDeadlineTasks().remove(taskNum);
        _display.getDeadlineTasks().remove(completedTask);
        _display.getCompletedTasks().add(completedTask);
        return completedTask;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandInvalid.java
``` java
 */

package entity;
/**
 * This class is for any invalid commands
 */
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandInvalid implements Command {
	private boolean _updateFile = false;
	private boolean _saveHistory = false;
    private Logger _logger = GlobalLogger.getLogger();

	public CommandInvalid() {
	}

	public Display execute(Display display) {
        assert display != null: "Invalid: null display";
        _logger.log(Level.INFO, "Invalid Command");
	    setDisplay(display);
		return display;
	}

	private void setDisplay(Display display) {
        display.setMessage(GlobalConstants.MESSAGE_ERROR_INVALID_COMMAND);
        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        display.setTaskIndices(new ArrayList<Integer>());
        display.setConflictingTasksIndices(new ArrayList<Integer>());
    }
	
	public boolean requiresSaveHistory() {
		return _saveHistory;
	}

	public boolean requiresUpdateFile() {
		return _updateFile;
	}
}
```
###### CS2103\src\entity\CommandPostpone.java
``` java
 */
package entity;

/**
 * This command is for postponing times of events and deadlines
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandPostpone implements Command {
    private int _taskNumber;
    private ArrayList<String> _parameters;
    private Calendar _time;
    private String _msg;
    private boolean _updateFile = true;;
    private boolean _saveHistory = true;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandPostpone() {
        this._taskNumber = -1;
    }

    public CommandPostpone(Integer taskNumber, Calendar time, ArrayList<String> parameters) {
        assert parameters != null;
        assert taskNumber != null;
        this._taskNumber = taskNumber - 1;
        this._time = time;
        this._parameters = parameters;
    }
    
    public Display execute(Display display) {
        assert display != null: "Postpone: null display";
        if (isInvalidCommand(display)) {
            _logger.log(Level.INFO, "Postpone: Invalid parameters");
            setInvalidDisplay(display);
            return display;
        }
        postpone(display);
        display.setMessage(_msg);
        return display;
    }

    public void postpone(Display display) {
        if (_taskNumber < display.getVisibleDeadlineTasks().size()) {
            _logger.log(Level.INFO, "Postpone: Postpone deadline");
            postponeDeadline(display);
        } else {
            _taskNumber -= display.getVisibleDeadlineTasks().size();
            _logger.log(Level.INFO, "Postpone: Postpone event");
            postponeEvent(display);
        }
    }

    /**
     * checks which parameters are being postponed
     * and increment them accordingly
     */
    public void postponeEvent(Display display) {
        TaskEvent task = display.getVisibleEvents().remove(_taskNumber);
        display.getEventTasks().remove(task);
        for (int i = 0; i < _parameters.size(); i++) {
            String parameter = _parameters.get(i).trim().toLowerCase();
            switch (parameter) {
            case GlobalConstants.YEAR:
                addYear(task.getStartDate());
                addYear(task.getEndDate());
                break;
            case GlobalConstants.MONTH:
                addMonth(task.getStartDate());
                addMonth(task.getEndDate());
                break;
            case GlobalConstants.DAY:
                addDay(task.getStartDate());
                addDay(task.getEndDate());
                break;
            case GlobalConstants.HOUR:
                addHour(task.getStartDate());
                addHour(task.getEndDate());
                break;
            case GlobalConstants.MINUTE:
                addMinute(task.getStartDate());
                addMinute(task.getEndDate());
                break;
            }
        }
        new CommandAddEvent(task).execute(display);
        _msg = GlobalConstants.MESSAGE_POSTPONED + task.getDescription();
        setOverdue(task);
    }

    /**
     * checks which parameters are being postponed
     * and increment them accordingly
     */
    public void postponeDeadline(Display display) {
        TaskDeadline task = display.getVisibleDeadlineTasks().remove(_taskNumber);
        display.getDeadlineTasks().remove(task);
        for (int i = 0; i < _parameters.size(); i++) {
            String parameter = _parameters.get(i).trim().toLowerCase();
            switch (parameter) {
            case GlobalConstants.YEAR:
                addYear(task.getEndDate());
                break;
            case GlobalConstants.MONTH:
                addMonth(task.getEndDate());
                break;
            case GlobalConstants.DAY:
                addDay(task.getEndDate());
                break;
            case GlobalConstants.HOUR:
                addHour(task.getEndDate());
                break;
            case GlobalConstants.MINUTE:
                addMinute(task.getEndDate());
                break;
            }
        }
        new CommandAddDeadlineTask(task).execute(display);
        _msg = GlobalConstants.MESSAGE_POSTPONED + task.getDescription();
        setOverdue(task);
    }

    /**
     * This method resets the overdue flag
     * of the postponed task
     */
    private void setOverdue(TaskEvent task) {
        if(task.getEndDate().before(Calendar.getInstance())){
            task.setIsOverdue(true);
        }else{
            task.setIsOverdue(false);
        }
    }

    private void setOverdue(TaskDeadline task) {
        if(task.getEndDate().before(Calendar.getInstance())){
            task.setIsOverdue(true);
        }else{
            task.setIsOverdue(false);
        }
    }

    private void addMinute(Calendar oldTime) {
        oldTime.set(Calendar.MINUTE,
                oldTime.get(Calendar.MINUTE) + _time.get(Calendar.MINUTE));
    }

    private void addHour(Calendar oldTime) {
        oldTime.set(Calendar.HOUR_OF_DAY,
                oldTime.get(Calendar.HOUR_OF_DAY) + _time.get(Calendar.HOUR_OF_DAY));
    }

    private void addDay(Calendar oldTime) {
        oldTime.set(Calendar.DATE, oldTime.get(Calendar.DATE) + _time.get(Calendar.DATE));
    }

    private void addMonth(Calendar oldTime) {
        oldTime.set(Calendar.MONTH, oldTime.get(Calendar.MONTH) + _time.get(Calendar.MONTH));
    }

    private void addYear(Calendar oldTime) {
        oldTime.set(Calendar.YEAR, oldTime.get(Calendar.YEAR) + _time.get(Calendar.YEAR));
    }

    private void setInvalidDisplay(Display display) {
        _updateFile = false;
        _saveHistory = false;
        display.setMessage(_msg);
        display.setTaskIndices(null);
        display.setConflictingTasksIndices(null);
    }

    private boolean isInvalidCommand(Display display) {
        if (hasInvalidTaskNumber(display)) {
            return true;
        } else if (hasInvalidTime()) {
            return true;
        }
        return false;
    }

    private boolean hasInvalidTime() {
        return false;
    }

    /**
     * this method takes into accounts that only
     * deadline tasks and events can be postponed
     */
    private boolean hasInvalidTaskNumber(Display display) {
        if (_taskNumber < 0) {
            _msg = GlobalConstants.MESSAGE_ERROR_INVALID_INDEX;
            return true;
        } else {
            int minIndex = 0;
            int maxIndex = display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size() - 1;
            if ((_taskNumber < minIndex) || (_taskNumber > maxIndex)) {
                _msg = GlobalConstants.MESSAGE_ERROR_POSTPONE_INVALID_TASK_TYPES;
                return true;
            }
        }
        return false;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandRedo.java
``` java
 */
package entity;

/**
 * This command is to redo any previously
 * undone commands
 */
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import history.History;

public class CommandRedo implements Command {
    private boolean _updateFile = true;
    private boolean _saveHistory = false;
    private int _count;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandRedo() {
        _count = 1;
    }

    public CommandRedo(int count) {
        this._count = count;
    }

    public Display execute(Display display) {
        assert display != null: "Redo: null display";
        Display nextDisplay = History.getDisplay(_count);
        if (nextDisplay == null) {
            _logger.log(Level.INFO, "Redo: At last state");
            _updateFile = false;
            display.setMessage(GlobalConstants.MESSAGE_ERROR_REDO);
            return display;
        }
        display = setDisplay(nextDisplay);
        return display;
    }

    private Display setDisplay(Display nextDisplay) {
        Display display;
        display = nextDisplay.deepClone();
        display.setOverdueTasks();
        display.setTaskIndices(new ArrayList<Integer>());
        display.setConflictingTasksIndices(new ArrayList<Integer>());
        display.setMessage(GlobalConstants.MESSAGE_REDO);
        return display;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandShow.java
``` java
 */
package entity;

/**
 * This command is for filtering the visible tasks
 * to match certain criteria
 */
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandShow implements Command {
    private String _msgShow = "Displaying ";
    private boolean _updateFile = false;
    private boolean _saveHistory = true;
    private TaskEvent _searchedTask;
    private Display _display;
    private ArrayList<String> _taskTypes;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandShow() {
        _searchedTask = null;
    }

    public CommandShow(String keyword) {
        _searchedTask = new TaskEvent(keyword.trim().toLowerCase(), GlobalConstants.EMPTY_STRING, null, null,
                new ArrayList<String>());
        _taskTypes = new ArrayList<String>();
    }

    public CommandShow(String keyword, String location, Calendar start, Calendar end,
            ArrayList<String> tags) {
        if (keyword == null) {
            keyword = GlobalConstants.EMPTY_STRING;
        }
        if (location == null) {
            location = GlobalConstants.EMPTY_STRING;
        }
        if (tags == null) {
            tags = new ArrayList<String>();
        }
        _searchedTask = new TaskEvent(keyword.trim().toLowerCase(), location.trim().toLowerCase(), start, end,
                tags);
        _taskTypes = new ArrayList<String>();
    }

    public CommandShow(String keyword, String location, Calendar start, Calendar end, ArrayList<String> tags,
            ArrayList<String> taskTypes) {
        if (keyword == null) {
            keyword = GlobalConstants.EMPTY_STRING;
        }
        if (location == null) {
            location = GlobalConstants.EMPTY_STRING;
        }
        if (tags == null) {
            tags = new ArrayList<String>();
        }
        if (taskTypes == null) {
            taskTypes = new ArrayList<String>();
        }
        _searchedTask = new TaskEvent(keyword.trim().toLowerCase(), location.trim().toLowerCase(), start, end,
                tags);
        this._taskTypes = taskTypes;
    }

    public Display execute(Display oldDisplay) {
        assert oldDisplay != null : "Show: null display";
        initialiseDisplay(oldDisplay);
        if (isShowAll()) {
            _logger.log(Level.INFO, "Show: Show all");
            setShowAll(oldDisplay);
            return oldDisplay;
        }
        if (isInvalidDateRange()) {
            _logger.log(Level.INFO, "Show: Invalid time range");
            setInvalidDisplay(oldDisplay);
            return oldDisplay;

        }
        this._display = oldDisplay.deepClone();

        showTasks();
        if (hasNoTasksFound()) {
            _logger.log(Level.INFO, "Show: No tasks");
            oldDisplay.setMessage(GlobalConstants.MESSAGE_NO_TASKS);
            return oldDisplay;
        } else {
            _logger.log(Level.INFO, "Show: No errors");
            _display.setMessage(getFeedback());
        }

        return _display;
    }

    /**
     * This method checks if there are no tasks matching the filter
     */
    private boolean hasNoTasksFound() {
        int numVisible = _display.getVisibleCompletedTasks().size()
                + _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size() + _display.getVisibleReservedTasks().size();
        return numVisible == 0;
    }

    private void initialiseDisplay(Display oldDisplay) {
        oldDisplay.setTaskIndices(new ArrayList<Integer>());
        oldDisplay.setConflictingTasksIndices(new ArrayList<Integer>());
    }

    private void setInvalidDisplay(Display oldDisplay) {
        _updateFile = false;
        _saveHistory = false;
        oldDisplay.setMessage(GlobalConstants.MESSAGE_ERROR_DATE_RANGE);
    }

    // returns true if end date is before start date
    private boolean isInvalidDateRange() {
        if ((_searchedTask.getStartDate() != null) && (_searchedTask.getEndDate() != null)) {
            if (_searchedTask.getStartDate().after(_searchedTask.getEndDate())) {
                return true;
            }
        }
        return false;
    }

    private void setShowAll(Display oldDisplay) {
        oldDisplay.setMessage(GlobalConstants.MESSAGE_SHOW_ALL);
        oldDisplay.setVisibleDeadlineTasks(oldDisplay.getDeadlineTasks());
        oldDisplay.setVisibleEvents(oldDisplay.getEventTasks());
        oldDisplay.setVisibleFloatTasks(oldDisplay.getFloatTasks());
        oldDisplay.setVisibleReservedTasks(oldDisplay.getReservedTasks());
        oldDisplay.setVisibleCompletedTasks(new ArrayList<Task>());
        initialiseDisplay(oldDisplay);
    }

    private boolean isShowAll() {
        if (_searchedTask.getDescription().isEmpty()) {
            if (_searchedTask.getLocation().isEmpty()) {
                if ((_searchedTask.getStartDate() == null) && (_searchedTask.getEndDate() == null)) {
                    if (_searchedTask.getTags().isEmpty()) {
                        if (_taskTypes.isEmpty()) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * This method sets the feedback to the user
     */
    private String getFeedback() {
        if (!_taskTypes.isEmpty()) {
            for (int i = 0; i < _taskTypes.size(); i++) {
                _msgShow += _taskTypes.get(i) + GlobalConstants.SPACE;
            }
            _msgShow += GlobalConstants.TASKS;
        } else {
            _msgShow += GlobalConstants.ALL_TASKS;
        }
        if (!_searchedTask.getDescription().isEmpty()) {
            _msgShow += GlobalConstants.CONTAINING + _searchedTask.getDescription();
        }
        if (!_searchedTask.getLocation().isEmpty()) {
            _msgShow += GlobalConstants.AT + _searchedTask.getLocation();
        }
        if ((_searchedTask.getStartDate() != null) && (_searchedTask.getEndDate() != null)) {
            SimpleDateFormat format1 = new SimpleDateFormat(GlobalConstants.DATE_FORMAT);
            String startDate = format1.format(_searchedTask.getStartDate().getTime());
            String endDate = format1.format(_searchedTask.getEndDate().getTime());

            _msgShow += GlobalConstants.FROM + startDate + GlobalConstants.TO + endDate;
        }
        if (!_searchedTask.getTags().isEmpty()) {
            _msgShow += GlobalConstants.TAGGED;
            for (int i = 0; i < _searchedTask.getTags().size(); i++) {
                if (i == 0) {
                    _msgShow += GlobalConstants.SPACE + _searchedTask.getTags().get(i);
                } else {
                    _msgShow += GlobalConstants.COMMA_SPACE + _searchedTask.getTags().get(i);
                }
            }
        }
        return _msgShow;
    }

    private void showTasks() {
        getFloatTasks();
        getEventTasks();
        getDeadLineTasks();
        getReservedTasks();
        getTaskType();
        return;
    }

    private void getTaskType() {
        if (!isTaskTypesEmpty()) {
            for (int i = 0; i < _taskTypes.size(); i++) {
                _taskTypes.set(i, _taskTypes.get(i).toLowerCase());
            }
            if (!_taskTypes.contains(GlobalConstants.TASK_TYPE_EVENT)) {
                _display.setVisibleEvents(new ArrayList<TaskEvent>());
            }
            if (!_taskTypes.contains(GlobalConstants.TASK_TYPE_DEADLINE)) {
                _display.setVisibleDeadlineTasks(new ArrayList<TaskDeadline>());
            }
            if (!_taskTypes.contains(GlobalConstants.TASK_TYPE_FLOAT)) {
                _display.setVisibleFloatTasks(new ArrayList<TaskFloat>());
            }
            if (!_taskTypes.contains(GlobalConstants.TASK_TYPE_RESERVED)) {
                _display.setVisibleReservedTasks(new ArrayList<TaskReserved>());
            }
            if (_taskTypes.contains(GlobalConstants.TASK_TYPE_COMPLETED)) {
                getCompletedTasks();
            }
        }
    }

    private boolean isTaskTypesEmpty() {
        if (_taskTypes == null) {
            return true;
        } else if (_taskTypes.isEmpty()) {
            return true;
        }
        return false;
    }

    /**
     * Gets completed tasks matching the filter
     */
    private void getCompletedTasks() {
        Task task;
        _display.setVisibleCompletedTasks(new ArrayList<Task>());
        for (int i = 0; i < _display.getCompletedTasks().size(); i++) {
            task = _display.getCompletedTasks().get(i);
            if (containsKeyword(task)) {
                if (atLocation(task)) {
                    if (containsTag(task)) {
                        if (withinTimeRange(task)) {
                            _display.getVisibleCompletedTasks().add(task);
                        }
                    }
                }
            }
        }
    }

    /**
     * Gets deadline tasks matching the filter
     */
    private void getDeadLineTasks() {
        TaskDeadline task;
        _display.setVisibleDeadlineTasks(new ArrayList<TaskDeadline>());
        for (int i = 0; i < _display.getDeadlineTasks().size(); i++) {
            task = _display.getDeadlineTasks().get(i);
            if (containsKeyword(task)) {
                if (atLocation(task)) {
                    if (containsTag(task)) {
                        if (withinTimeRange(task)) {
                            _display.getVisibleDeadlineTasks().add(task);
                        }
                    }
                }
            }
        }
    }

    /**
     * Gets event tasks matching the filter
     */
    private void getEventTasks() {
        TaskEvent task;
        _display.setVisibleEvents(new ArrayList<TaskEvent>());
        for (int i = 0; i < _display.getEventTasks().size(); i++) {
            task = _display.getEventTasks().get(i);
            if (containsKeyword(task)) {
                if (atLocation(task)) {
                    if (containsTag(task)) {
                        if (withinTimeRange(task)) {
                            _display.getVisibleEvents().add(task);
                        }
                    }
                }
            }
        }
    }

    /**
     * Gets float tasks matching the filter
     */
    private void getFloatTasks() {
        TaskFloat task;
        _display.setVisibleFloatTasks(new ArrayList<TaskFloat>());
        for (int i = 0; i < _display.getFloatTasks().size(); i++) {
            task = _display.getFloatTasks().get(i);
            if (containsKeyword(task)) {
                if (atLocation(task)) {
                    if (containsTag(task)) {
                        _display.getVisibleFloatTasks().add(task);

                    }
                }
            }
        }
    }

    /**
     * Gets reserved tasks matching the filter
     */
    private void getReservedTasks() {
        TaskReserved task;
        _display.setVisibleReservedTasks(new ArrayList<TaskReserved>());
        for (int i = 0; i < _display.getReservedTasks().size(); i++) {
            task = _display.getReservedTasks().get(i);
            if (containsKeyword(task)) {
                if (atLocation(task)) {
                    if (containsTag(task)) {
                        if (withinTimeRange(task)) {
                            _display.getVisibleReservedTasks().add(task);
                        }
                    }
                }
            }
        }
    }

    private boolean containsTag(Task task) {
        if (_searchedTask.getTags().isEmpty()) {
            return true;
        }
        boolean containsTags = false;
        for (int i = 0; i < _searchedTask.getTags().size(); i++) {
            for (int j = 0; j < task.getTags().size(); j++) {
                containsTags = false;
                if (_searchedTask.getTags().get(i).toLowerCase()
                        .equals(task.getTags().get(j).trim().toLowerCase())) {
                    containsTags = true;
                    break;
                }
            }
            if (containsTags == false) {
                return false;
            }
        }
        return true;
    }

    private boolean withinTimeRange(Task task) {
        if ((_searchedTask.getStartDate() == null) && (_searchedTask.getEndDate() == null)) {
            return true;
        }
        if (task instanceof TaskEvent) {
            TaskEvent myTask = (TaskEvent) task;
            if (isWithinTimeRange(myTask)) {
                return true;
            }
        } else if (task instanceof TaskDeadline) {
            TaskDeadline myTask = (TaskDeadline) task;
            if (isWithinTimeRange(myTask)) {
                return true;
            }
        }
        return false;
    }

    private boolean withinTimeRange(TaskReserved task) {
        if ((_searchedTask.getStartDate() == null) && (_searchedTask.getEndDate() == null)) {
            return true;
        }
        for (int i = 0; i < task.getStartDates().size(); i++) {
            if (!task.getStartDates().get(i).before(_searchedTask.getStartDate())) {
                if (!task.getStartDates().get(i).after(_searchedTask.getEndDate())) {
                    return true;
                }
            } else if (!task.getEndDates().get(i).before(_searchedTask.getStartDate())) {
                return true;
            }

        }
        return false;
    }

    private boolean isWithinTimeRange(TaskEvent task) {
        if ((_searchedTask.getStartDate() == null) && (_searchedTask.getEndDate() == null)) {
            return true;
        }
        if (!task.getStartDate().before(_searchedTask.getStartDate())) {
            if (!task.getStartDate().after(_searchedTask.getEndDate())) {
                return true;
            }
        } else if (!task.getEndDate().before(_searchedTask.getStartDate())) {
            return true;
        }
        return false;
    }

    private boolean isWithinTimeRange(TaskDeadline task) {
        if ((_searchedTask.getStartDate() == null) && (_searchedTask.getEndDate() == null)) {
            return true;
        }
        if (!task.getEndDate().before(_searchedTask.getStartDate())) {
            if (!task.getEndDate().after(_searchedTask.getEndDate())) {
                return true;
            }
        }
        return false;
    }

    private boolean atLocation(Task task) {
        if (_searchedTask.getLocation().isEmpty()) {
            return true;
        }
        if (task.getLocation() == null) {
            return false;
        }
        if (task.getLocation().equalsIgnoreCase(_searchedTask.getLocation())) {
            return true;
        }
        return false;
    }

    private boolean containsKeyword(Task task) {
        String[] keywords = _searchedTask.getDescription().split(GlobalConstants.SPACE);
        for (int i = 0; i < keywords.length; i++) {
            if (!task.getDescription().toLowerCase().contains(keywords[i])) {
                return false;
            }
        }
        return true;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandUndo.java
``` java
 */

package entity;

/**
 * This command is to undo previously entered
 * commands
 */
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import history.History;

public class CommandUndo implements Command {
    private boolean _updateFile = true;
    private boolean _saveHistory = false;
    private int _count;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandUndo() {
        _count = -1;
    }

    public CommandUndo(int count) {
        this._count = -1 * count;
    }

    public Display execute(Display display) {
        assert display != null: "Undo: null display";
        Display prevDisplay = History.getDisplay(_count);
        if (prevDisplay == null) {
            _logger.log(Level.INFO, "Undo: At last state");
            _updateFile = false;
            display.setMessage(GlobalConstants.MESSAGE_ERROR_UNDO);
            return display;
        }
        display = setDisplay(prevDisplay);
        return display;
    }

    private Display setDisplay(Display prevDisplay) {
        Display display;
        display = prevDisplay.deepClone();
        display.setOverdueTasks();
        display.setTaskIndices(new ArrayList<Integer>());
        display.setConflictingTasksIndices(new ArrayList<Integer>());
        display.setMessage(GlobalConstants.MESSAGE_UNDO);
        return display;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandUndone.java
``` java
 */
package entity;

/**
 * This command is to mark any completed tasks
 * as incomplete again.
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

public class CommandUndone implements Command {
    private ArrayList<Integer> _taskNumbers;
    private ArrayList<Integer> _taskIndices = new ArrayList<Integer>();
    private ArrayList<Task> _tasks = new ArrayList<Task>();
    private Display _display;
    private String _msgUndone = "Undone task: ";
    private String _msgInvalidNum = "You have specified invalid task numbers: ";
    private boolean _saveHistory = true;
    private boolean _updateFile = true;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandUndone() {
        this._taskNumbers = null;
        this._display = null;
    }

    public CommandUndone(ArrayList<Integer> taskNumbers) {
        this._taskNumbers = taskNumbers;
        this._display = null;
    }

    public Display execute(Display oldDisplay) {
        assert oldDisplay != null : "Undone: null display";
        this._display = oldDisplay;
        if (_taskNumbers != null) {
            if (hasInvalidTaskNumbers()) {
                _logger.log(Level.INFO, "Undone: Invalid Indices");
                setInvalidDisplay();
                return oldDisplay;
            }
            Collections.sort(_taskNumbers);
        }

        undoneTasksFromList();
        setDisplay(GlobalConstants.GUI_ANIMATION_ADD, _taskNumbers);
        return _display;
    }

    /**
     * sets up variables if command has invalid parameters
     */
    private void setInvalidDisplay() {
        _updateFile = false;
        _saveHistory = false;
        _display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
        _display.setMessage(_msgInvalidNum);
    }

    private void setDisplay(String commandType, ArrayList<Integer> completedTasks) {
        _display.setCommandType(commandType);
        incrementTaskNumbers();
        _display.setTaskIndices(completedTasks);
        getTaskIndices();
    }

    /**
     * gets the new indices of the undone tasks for animation purposes
     */
    private void getTaskIndices() {
        for (int i = 0; i < _tasks.size(); i++) {
            Task task = _tasks.get(i);
            int index = getIndex(task);
            _taskIndices.add(index);
        }
    }

    private int getIndex(Task task) {
        if (task instanceof TaskDeadline) {
            return _display.getVisibleDeadlineTasks().indexOf(task) + 1;
        } else if (task instanceof TaskEvent) {
            return _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().indexOf(task) + 1;
        } else {
            return _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                    + _display.getVisibleFloatTasks().indexOf(task) + 1;
        }
    }

    private void incrementTaskNumbers() {
        if (_taskNumbers != null) {
            for (int i = 0; i < _taskNumbers.size(); i++) {
                _taskNumbers.set(i, _taskNumbers.get(i) + 1);
            }
        }
    }

    private boolean hasInvalidTaskNumbers() {
        ArrayList<Integer> invalidTaskNumbers = new ArrayList<Integer>();
        int taskNum, maxNum = getNumOfVisibleTasks(), minNum = getMinimumTaskNum();
        for (int i = 0; i < _taskNumbers.size(); i++) {
            taskNum = _taskNumbers.get(i);
            if (isTaskNumberInvalid(taskNum, maxNum, minNum)) {
                feedbackInvalidNumbers(invalidTaskNumbers, taskNum);
                invalidTaskNumbers.add(taskNum);
            }
        }
        return (invalidTaskNumbers.size() > 0);
    }

    private int getMinimumTaskNum() {
        int minNum = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size() + _display.getVisibleReservedTasks().size() + 1;
        return minNum;
    }

    private int getNumOfVisibleTasks() {
        int numOfTasks = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size() + _display.getVisibleReservedTasks().size()
                + _display.getVisibleCompletedTasks().size();
        return numOfTasks;
    }

    /**
     * set feedback msg for user
     */
    private void feedbackInvalidNumbers(ArrayList<Integer> invalidTaskNumbers, int taskNum) {
        if (invalidTaskNumbers.size() == 0) {
            _msgInvalidNum += taskNum;
        } else {
            _msgInvalidNum += ", " + taskNum;
        }
    }

    private boolean isTaskNumberInvalid(int taskNum, int max, int min) {
        return (taskNum > max) || (taskNum < min);
    }

    private void undoneTasksFromList() {
        if (isUndoneAll()) {
            undoneAllVisibleDoneTasks();
        } else {
            undoneMultipleDoneTasks();
        }
        return;
    }

    private void undoneMultipleDoneTasks() {
        Collections.sort(_taskNumbers);
        for (int i = 0; i < _taskNumbers.size(); i++) {
            Task completedTask = getTask(i);
            _display.getVisibleCompletedTasks().remove(completedTask);
            markUndoneTask(completedTask);
            feedbackUndoneTasks(completedTask, i);
        }
        _display.setMessage(_msgUndone);
    }

    private Task getTask(int i) {
        int index = _taskNumbers.get(i) - _display.getVisibleDeadlineTasks().size()
                - _display.getVisibleEvents().size() - _display.getVisibleFloatTasks().size()
                - _display.getVisibleReservedTasks().size() - 1;
        return _display.getCompletedTasks().remove(index);
    }

    private void undoneAllVisibleDoneTasks() {
        int numOfVisibleCompletedTasks = _display.getVisibleCompletedTasks().size();
        for (int i = numOfVisibleCompletedTasks - 1; i >= 0; i--) {
            Task completedTask = _display.getCompletedTasks().remove(i);
            markUndoneTask(completedTask);

        }
        _display.setVisibleCompletedTasks(_display.getCompletedTasks());
        _display.setMessage(GlobalConstants.MESSAGE_ALL_UNDONE);
    }

    private boolean isUndoneAll() {
        return _taskNumbers == null;
    }

    private void feedbackUndoneTasks(Task undoneTask, int i) {
        if (i == 0) {
            _msgUndone += GlobalConstants.INVERTED_COMMAS + undoneTask.getDescription()
                    + GlobalConstants.INVERTED_COMMAS;
        } else {
            _msgUndone += GlobalConstants.COMMA_SPACE_INVERTED_COMMAS + undoneTask.getDescription()
                    + GlobalConstants.INVERTED_COMMAS;
        }
    }

    private void markUndoneTask(Task completedTask) {
        _tasks.add(completedTask);
        if (completedTask instanceof TaskEvent) {
            undoneTaskEvent(completedTask);
        } else if (completedTask instanceof TaskDeadline) {
            undoneTaskDeadline(completedTask);
        } else if (completedTask instanceof TaskFloat) {
            undoneTaskFloat(completedTask);
        }
        return;
    }

    private void undoneTaskEvent(Task completedTask) {
        TaskEvent task = (TaskEvent) completedTask;
        Command addCommand = new CommandAddEvent(task);
        _display = addCommand.execute(_display);
    }

    private void undoneTaskDeadline(Task completedTask) {
        TaskDeadline task = (TaskDeadline) completedTask;
        Command addCommand = new CommandAddDeadlineTask(task);
        _display = addCommand.execute(_display);
    }

    private void undoneTaskFloat(Task completedTask) {
        TaskFloat task = (TaskFloat) completedTask;
        Command addCommand = new CommandAddFloatTask(task);
        _display = addCommand.execute(_display);
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\CommandUpdate.java
``` java
 */
package entity;

/**
 * This command is to edit any parameters
 * of a task
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;

@SuppressWarnings("serial")
public class CommandUpdate extends TaskEvent implements Command {
    private Integer _reservedSlotIndex;
    private Integer _taskNumber;
    private ArrayList<String> _removeTags;
    private Display _display;
    private boolean _timeChanged = false;
    private boolean _updateFile = true;;
    private boolean _saveHistory = true;
    private String _msgEdit = "Edited : \"";
    private ArrayList<Integer> _removeReservedSlotIndex;
    private Logger _logger = GlobalLogger.getLogger();

    public CommandUpdate() {
        super();
        _removeTags = null;
        this._taskNumber = null;
    }

    public CommandUpdate(Integer taskNumber, String description, String location, Calendar startDate,
            Calendar endDate, ArrayList<String> addTags, ArrayList<String> removeTags) {
        super(description, location, startDate, endDate, addTags);
        this._removeTags = removeTags;
        _updateFile = true;
        this._taskNumber = taskNumber;
        this._reservedSlotIndex = null;
    }

    public CommandUpdate(Integer taskNumber, Integer reservedSlotIndex, String description, String location,
            Calendar startDate, Calendar endDate, ArrayList<String> addTags, ArrayList<String> removeTags,
            ArrayList<Integer> removeReservedSlotIndex) {
        super(description, location, startDate, endDate, addTags);
        this._removeTags = removeTags;
        _updateFile = true;
        this._taskNumber = taskNumber;
        this._reservedSlotIndex = reservedSlotIndex;
        this._removeReservedSlotIndex = removeReservedSlotIndex;
    }

    public Display execute(Display oldDisplay) {
        assert oldDisplay != null : "Update: null display";
        _display = oldDisplay;
        if (hasInvalidTaskNumber()) {
            _logger.log(Level.INFO, "Update: Invalid Indices");
            _msgEdit = GlobalConstants.MESSAGE_ERROR_TASK_NUMBER;
            setInvalidDisplay();
            return _display;
        }
        if (isInvalidDateRange()) {
            _logger.log(Level.INFO, "Update: Invalid dates");
            _msgEdit = GlobalConstants.MESSAGE_ERROR_DATE_RANGE;
            setInvalidDisplay();
            return oldDisplay;
        }
        editTask();
        _display.setMessage(_msgEdit);
        return _display;
    }

    // returns true if end date is before start date
    private boolean isInvalidDateRange() {
        if ((getStartDate() != null) && (getEndDate() != null)) {
            if (getStartDate().after(getEndDate())) {
                return true;
            }
        }
        return false;
    }

    /**
     * sets up variables if command has invalid parameters
     */
    private void setInvalidDisplay() {
        _updateFile = false;
        _saveHistory = false;
        _display.setMessage(_msgEdit);
        _display.setTaskIndices(new ArrayList<Integer>());
        _display.setConflictingTasksIndices(new ArrayList<Integer>());
    }

    private boolean hasInvalidTaskNumber() {
        int numOfTasks = 0;
        numOfTasks += _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                + _display.getVisibleFloatTasks().size() + _display.getVisibleReservedTasks().size();
        return ((_taskNumber > numOfTasks) || (_taskNumber < 1));
    }

    /**
     * Maps task number to task types
     */
    private void editTask() {
        if (_taskNumber <= _display.getVisibleDeadlineTasks().size()) {
            _logger.log(Level.INFO, "Update: Deadline");
            editDeadline();
        } else {
            _taskNumber -= _display.getVisibleDeadlineTasks().size();
            if (_taskNumber <= _display.getVisibleEvents().size()) {
                _logger.log(Level.INFO, "Update: Event");
                editEvent();
            } else {
                _taskNumber -= _display.getVisibleEvents().size();
                if (_taskNumber <= _display.getVisibleFloatTasks().size()) {
                    _logger.log(Level.INFO, "Update: Float");
                    editFloat();
                } else {
                    _taskNumber -= _display.getVisibleFloatTasks().size();
                    _logger.log(Level.INFO, "Update: Reserved");
                    editReserved();
                }
            }
        }
    }

    private void editDeadline() {
        TaskDeadline task = _display.getVisibleDeadlineTasks().get(_taskNumber - 1);
        if (isInvalidEditDeadline(task)) {
            _logger.log(Level.INFO, "Update: Invalid deadline edit");
            setInvalidDisplay();
            return;
        }
        _msgEdit += task.getDescription() + GlobalConstants.INVERTED_COMMAS;
        editDescription(task);
        editLocation(task);
        editTags(task);
        editEndDate(task);
        changeDeadlineTaskType(task);

    }

    private void editEvent() {
        TaskEvent task = _display.getVisibleEvents().get(_taskNumber - 1);
        if (isInvalidEditEvent(task)) {
            _logger.log(Level.INFO, "Update: Invalid event edit");
            setInvalidDisplay();
            return;
        }
        _msgEdit += task.getDescription() + GlobalConstants.INVERTED_COMMAS;
        editDescription(task);
        editLocation(task);
        editTags(task);
        editEndDate(task);
        editStartDate(task);
        changeEventTaskType(task);
        if (_timeChanged) {
            _display.getEventTasks().remove(task);
            _display.getVisibleEvents().remove(task);
            Command add = new CommandAddEvent(task);
            add.execute(_display);
        }
    }

    private void editFloat() {
        TaskFloat task = _display.getVisibleFloatTasks().get(_taskNumber - 1);
        if (isInvalidEditFloat(task)) {
            _logger.log(Level.INFO, "Update: Invalid float edit");
            setInvalidDisplay();
            return;
        }
        _msgEdit += task.getDescription() + GlobalConstants.INVERTED_COMMAS;
        editDescription(task);
        editLocation(task);
        editTags(task);
        setTaskIndices(task);
        if (hasChangeFloatTaskType(task)) {
            _display.getVisibleFloatTasks().remove(_taskNumber - 1);
            _display.getFloatTasks().remove(task);
        }
    }

    private int getIndex(Task task) {
        int index = 0;
        if (task instanceof TaskEvent) {
            index = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().indexOf(task) + 1;
        } else if (task instanceof TaskDeadline) {
            index = _display.getVisibleDeadlineTasks().indexOf(task) + 1;
        } else if (task instanceof TaskFloat) {
            index = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                    + _display.getVisibleFloatTasks().indexOf(task) + 1;
        } else if (task instanceof TaskReserved) {
            index = _display.getVisibleDeadlineTasks().size() + _display.getVisibleEvents().size()
                    + _display.getVisibleFloatTasks().size()
                    + _display.getVisibleReservedTasks().indexOf(task) + 1;
        }
        return index;
    }

    private void editReserved() {
        TaskReserved task = _display.getReservedTasks().get(_taskNumber - 1);
        if (isInvalidEditReserved(task)) {
            _logger.log(Level.INFO, "Update: Invalid reserved edit");
            setInvalidDisplay();
            return;
        }
        _msgEdit += task.getDescription() + GlobalConstants.INVERTED_COMMAS;
        editDescription(task);
        editLocation(task);
        editTags(task);
        editTimeSlot(task);
        removeTimeSlot(task);
        setTaskIndices(task);
    }

    /**
     * this method removes time slots from a reserved task
     */
    private void removeTimeSlot(TaskReserved task) {
        if (_removeReservedSlotIndex != null) {
            Collections.sort(_removeReservedSlotIndex);
            for (int i = 0; i < _removeReservedSlotIndex.size(); i++) {
                int index = _removeReservedSlotIndex.get(i);
                task.getStartDates().remove(index - 1 - i);
                task.getEndDates().remove(index - 1 - i);
            }
        }
    }

    /**
     * this method checks if user wants to edit timeslot or add a timeslot
     */
    private void editTimeSlot(TaskReserved task) {
        if (_reservedSlotIndex != null) {
            editTime(task);
        } else {
            addTimeSlot(task);
        }
    }

    /**
     * this method adds a time slot to a reserved task
     */
    private void addTimeSlot(TaskReserved task) {
        if ((getStartDate() != null) && (getEndDate() != null)) {
            task.getStartDates().add(getStartDate());
            task.getEndDates().add(getEndDate());
        }else{
            _msgEdit = GlobalConstants.MESSAGE_ERROR_SPECIFY_BOTH_START_END;
        }
    }

    /**
     * this method edits a time slot of a reserved task
     */
    private void editTime(TaskReserved task) {
        editStart(task);
        editEnd(task);
    }

    private void editStart(TaskReserved task) {
        Calendar newTime = Calendar.getInstance();
        if (getStartDate() != null) {
            if (isChangeTimeOnly(getStartDate())) {
                newTime.setTimeInMillis(task.getStartDates().get(_reservedSlotIndex - 1).getTimeInMillis());
                newTime.set(Calendar.HOUR_OF_DAY, getStartDate().get(Calendar.HOUR_OF_DAY));
                newTime.set(Calendar.MINUTE, getStartDate().get(Calendar.MINUTE));
            } else {
                newTime.setTimeInMillis(getStartDate().getTimeInMillis());
            }

            if (newTime.before(task.getEndDates().get(_reservedSlotIndex - 1))) {
                Calendar start = task.getStartDates().get(_reservedSlotIndex - 1);
                start.setTimeInMillis(newTime.getTimeInMillis());
            } else {
                _msgEdit = GlobalConstants.MESSAGE_ERROR_START_AFTER_END;
            }
        }

    }

    private void editEnd(TaskReserved task) {
        Calendar newTime = Calendar.getInstance();
        if (getEndDate() != null) {
            if (isChangeTimeOnly(getEndDate())) {
                newTime.setTimeInMillis(task.getEndDates().get(_reservedSlotIndex - 1).getTimeInMillis());
                newTime.set(Calendar.HOUR_OF_DAY, getEndDate().get(Calendar.HOUR_OF_DAY));
                newTime.set(Calendar.MINUTE, getEndDate().get(Calendar.MINUTE));
            } else {
                newTime.setTimeInMillis(getEndDate().getTimeInMillis());
            }
            if (newTime.after(task.getStartDates().get(_reservedSlotIndex - 1))) {
                Calendar end = task.getEndDates().get(_reservedSlotIndex - 1);
                end.setTimeInMillis(newTime.getTimeInMillis());
            } else {
                _msgEdit = GlobalConstants.MESSAGE_ERROR_START_AFTER_END;
            }
        }
    }

    /**
     * this method checks for any invalid parameters when user has specified to
     * edit a reserved task
     */
    private boolean isInvalidEditReserved(TaskReserved task) {
        if (hasNoLocationToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_LOCATION;
            return true;
        }
        if (hasNoTagsToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_TAGS;
            return true;
        }
        if (hasRemoveEndDate()) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_REMOVE_END;
            return true;
        }
        if (hasRemoveStartDate()) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_REMOVE_START;
            return true;
        }
        if (_removeReservedSlotIndex != null) {
            if (!_removeReservedSlotIndex.isEmpty()) {
                if (hasInvalidIndices(task)) {
                    _msgEdit = GlobalConstants.MESSAGE_ERROR_INVALID_TIMESLOT;
                    return true;
                }
            }
        }
        return false;
    }

    private boolean hasInvalidIndices(TaskReserved task) {
        for (int i = 0; i < _removeReservedSlotIndex.size(); i++) {
            int index = _removeReservedSlotIndex.get(i);
            if ((index < 1) || (index > task.getStartDates().size())) {
                return true;
            }
        }
        return false;
    }

    /**
     * this method checks for any invalid parameters when user has specified to
     * edit a floating task
     */
    private boolean isInvalidEditFloat(TaskFloat task) {
        if (hasNoLocationToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_LOCATION;
            return true;
        }
        if (hasNoTagsToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_TAGS;
            return true;
        }
        if ((hasAddStartDate()) && (!hasAddEndDate())) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_ADD_START_DATE_ONLY;
            return true;
        }

        return false;
    }

    /**
     * this method checks for any invalid parameters when user has specified to
     * edit an event task
     */
    private boolean isInvalidEditEvent(TaskEvent task) {
        if (hasNoLocationToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_LOCATION;
            return true;
        }
        if (hasNoTagsToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_TAGS;
            return true;
        }
        if ((hasRemoveEndDate()) && (!hasRemoveStartDate())) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_REMOVE_END_DATE_ONLY;
            return true;

        }
        if ((getStartDate() != null) && (getEndDate() != null)) {
            if ((getStartDate().getTimeInMillis() != 0) && (getEndDate().getTimeInMillis() != 0)) {
                if (getStartDate().after(getEndDate())) {
                    _msgEdit = GlobalConstants.MESSAGE_ERROR_START_AFTER_END;
                    return true;
                }
            }
        }
        if ((hasAddStartDate()) && (!hasAddEndDate())) {
            if (isStartAfterEnd(task)) {
                _msgEdit = GlobalConstants.MESSAGE_ERROR_START_AFTER_END;
                return true;
            }
        }

        return false;
    }

    private boolean isStartAfterEnd(TaskEvent task) {
        if (getStartDate().after(task.getEndDate())) {
            return true;
        } else if (isChangeTimeOnly(getStartDate())) {
            Calendar start = Calendar.getInstance();
            start.setTimeInMillis(task.getStartDate().getTimeInMillis());
            start.set(Calendar.HOUR_OF_DAY, getStartDate().get(Calendar.HOUR_OF_DAY));
            start.set(Calendar.MINUTE, getStartDate().get(Calendar.MINUTE));
            if (start.after(task.getEndDate())) {
                return true;
            }
        }
        return false;
    }

    private boolean isChangeTimeOnly(Calendar time) {
        return (time.get(Calendar.YEAR) == 1);
    }

    /**
     * this method checks for any invalid parameters when user has specified to
     * edit a deadline task
     */
    private boolean isInvalidEditDeadline(TaskDeadline task) {
        if (hasNoLocationToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_LOCATION;
            return true;
        }
        if (hasNoTagsToRemove(task)) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_NO_TAGS;
            return true;
        }
        if ((hasRemoveStartDate())) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_REMOVE_START;
            return true;
        }
        if ((hasRemoveEndDate()) && (hasAddStartDate())) {
            _msgEdit = GlobalConstants.MESSAGE_ERROR_ADD_START_REMOVE_END;
            return true;

        }

        return false;
    }

    @SuppressWarnings("unused")
    private boolean hasRemoveTimeSlots() {
        if (_removeReservedSlotIndex != null) {
            if (!_removeReservedSlotIndex.isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private boolean hasRemoveEndDate() {
        if ((getEndDate() != null)) {
            if (getEndDate().getTimeInMillis() == 0) {
                return true;
            }
        }
        return false;
    }

    private boolean hasAddEndDate() {
        if ((getEndDate() != null)) {
            if (getEndDate().getTimeInMillis() != 0) {
                return true;
            }
        }
        return false;
    }

    private boolean hasAddStartDate() {
        if ((getStartDate() != null)) {
            if (getStartDate().getTimeInMillis() != 0) {
                return true;
            }
        }
        return false;
    }

    private boolean hasRemoveStartDate() {
        if ((getStartDate() != null)) {
            if (getStartDate().getTimeInMillis() == 0) {
                return true;
            }
        }
        return false;
    }

    private boolean hasNoTagsToRemove(Task task) {
        if (_removeTags == null) {
            return false;
        }
        if (_removeTags != null) {
            if ((!_removeTags.isEmpty()) && (task.getTags() == null)) {
                return true;
            } else if ((!_removeTags.isEmpty()) && (task.getTags().isEmpty())) {
                return true;
            }
        }
        return false;
    }

    private boolean hasNoLocationToRemove(Task task) {
        if (getLocation() != null) {
            if ((getLocation().equals(GlobalConstants.EMPTY_STRING)) && (task.getLocation() == null)) {
                return true;
            }
        }
        return false;
    }

    /**
     * checks if there is a conversion of task type from deadline to event/float
     * and converts accordingly
     */
    private boolean changeDeadlineTaskType(TaskDeadline task) {
        // assertFalse endDate==0 AND startDate != 0&null
        boolean hasTaskChanged = false;
        if (isConvertDeadlineToFloat()) {
            _logger.log(Level.INFO, "Update: Convert deadline to float");
            _display.getVisibleDeadlineTasks().remove(_taskNumber - 1);
            _display.getDeadlineTasks().remove(task);
            hasTaskChanged = convertDeadlineToFloat(task);
        }
        if (isConvertDeadlineToEvent(hasTaskChanged)) {
            _logger.log(Level.INFO, "Update: Convert deadline to event");
            _display.getVisibleDeadlineTasks().remove(_taskNumber - 1);
            _display.getDeadlineTasks().remove(task);
            convertDeadlineToEvent(task);
            hasTaskChanged = true;
        }
        if (!hasTaskChanged) {
            setTaskIndices(task);
        }
        return hasTaskChanged;
    }

    /**
     * sets the task indices array for UI to use in the animation
     */
    private void setTaskIndices(Task task) {
        ArrayList<Integer> indices = new ArrayList<Integer>();
        indices.add(getIndex(task));
        _display.setTaskIndices(indices);
        return;
    }

    private boolean convertDeadlineToFloat(TaskDeadline task) {
        boolean hasTaskChanged;
        Command addCommand = new CommandAddFloatTask(task.getDescription(), task.getLocation(),
                task.getTags());
        _display = addCommand.execute(_display);
        hasTaskChanged = true;
        return hasTaskChanged;
    }

    private void convertDeadlineToEvent(TaskDeadline task) {
        Command addCommand = new CommandAddEvent(task.getDescription(), task.getLocation(), getStartDate(),
                task.getEndDate(), task.getTags());
        _display = addCommand.execute(_display);
    }

    private boolean isConvertDeadlineToEvent(boolean hasTaskChanged) {
        if (getStartDate() != null) {
            if ((getStartDate().getTimeInMillis() != 0) && (!hasTaskChanged)) {
                return true;
            }
        }
        return false;
    }

    private boolean isConvertDeadlineToFloat() {
        if (getEndDate() != null) {
            if (getEndDate().getTimeInMillis() == 0) {
                return true;
            }
        }
        return false;
    }

    private void editTags(Task task) {
        if (_removeTags != null) {
            for (int i = 0; i < _removeTags.size(); i++) {
                String tag = _removeTags.get(i);
                task.getTags().remove(tag);
            }
        }

        if (getTags() != null) {
            for (int i = 0; i < getTags().size(); i++) {
                String tag = getTags().get(i);
                task.getTags().add(tag);
            }
        }
        return;
    }

    private void editStartDate(TaskEvent task) {
        if (getStartDate() != null) {
            if (getStartDate().getTimeInMillis() != 0) {
                _display.getVisibleEvents().remove(task);
                _display.getEventTasks().remove(task);
                if (getStartDate().get(Calendar.YEAR) == 1) {
                    task.getStartDate().set(Calendar.HOUR_OF_DAY, getStartDate().get(Calendar.HOUR_OF_DAY));
                    task.getStartDate().set(Calendar.MINUTE, getStartDate().get(Calendar.MINUTE));
                    _timeChanged = true;
                } else {
                    task.setStartDate(getStartDate());
                    _timeChanged = true;
                }
                new CommandAddEvent(task).execute(_display);
            }
        }
        resetOverdueStatus(task);
        return;
    }

    private void resetOverdueStatus(TaskEvent task) {
        if (task.getEndDate().before(Calendar.getInstance())) {
            task.setIsOverdue(true);
        } else {
            task.setIsOverdue(false);
        }
    }

    private void editEndDate(TaskEvent task) {
        if (getEndDate() != null) {
            if (getEndDate().getTimeInMillis() != 0) {
                if (getEndDate().get(Calendar.YEAR) == 1) {
                    task.getEndDate().set(Calendar.HOUR_OF_DAY, getEndDate().get(Calendar.HOUR_OF_DAY));
                    task.getEndDate().set(Calendar.MINUTE, getEndDate().get(Calendar.MINUTE));
                    _timeChanged = true;
                } else {
                    task.setEndDate(getEndDate());
                    _timeChanged = true;
                }
            }
        }
        resetOverdueStatus(task);
        return;
    }

    private void editEndDate(TaskDeadline task) {
        if (getEndDate() != null) {
            if (getEndDate().getTimeInMillis() != 0) {
                _display.getVisibleDeadlineTasks().remove(task);
                _display.getDeadlineTasks().remove(task);
                if (getEndDate().get(Calendar.YEAR) == 1) {
                    task.getEndDate().set(Calendar.HOUR_OF_DAY, getEndDate().get(Calendar.HOUR_OF_DAY));
                    task.getEndDate().set(Calendar.MINUTE, getEndDate().get(Calendar.MINUTE));
                } else {
                    task.setEndDate(getEndDate());
                }
                new CommandAddDeadlineTask(task).execute(_display);
            }
        }
        resetOverdueStatus(task);
        return;
    }

    private void resetOverdueStatus(TaskDeadline task) {
        if (task.getEndDate().before(Calendar.getInstance())) {
            task.setIsOverdue(true);
        } else {
            task.setIsOverdue(false);
        }
    }

    private void editLocation(Task task) {
        if (getLocation() != null) {
            if (getLocation().trim().isEmpty()) {
                task.setLocation(null);
            } else {
                task.setLocation(getLocation().trim());
            }
        }
        return;
    }

    private void editDescription(Task task) {
        if (getDescription() != null) {
            if (!getDescription().trim().isEmpty()) {
                task.setDescription(getDescription().trim());
            }
        }
        return;
    }

    /**
     * checks if there is a conversion of task type from event to deadline/float
     * and converts accordingly
     */
    private void changeEventTaskType(TaskEvent task) {
        boolean hasTaskChanged = false;
        if (isConvertEventToFloat()) {
            _logger.log(Level.INFO, "Update: Convert event to float");
            _display.getVisibleEvents().remove(task);
            _display.getEventTasks().remove(task);
            convertEventToFloat(task);
            hasTaskChanged = true;
        }
        if (isConvertEventToDeadline(hasTaskChanged)) {
            _logger.log(Level.INFO, "Update: Convert event to deadline");
            _display.getVisibleEvents().remove(task);
            _display.getEventTasks().remove(task);
            convertEventToDeadline(task);
            hasTaskChanged = true;
        }
        if (!hasTaskChanged) {
            setTaskIndices(task);
        }
        return;
    }

    private void convertEventToFloat(TaskEvent task) {
        Command addCommand = new CommandAddFloatTask(task.getDescription(), task.getLocation(),
                task.getTags());
        _display = addCommand.execute(_display);
    }

    private void convertEventToDeadline(TaskEvent task) {
        Command addCommand = new CommandAddDeadlineTask(task.getDescription(), task.getLocation(),
                task.getEndDate(), task.getTags());
        _display = addCommand.execute(_display);
    }

    private boolean isConvertEventToFloat() {
        if ((getStartDate() != null) && (getEndDate() != null)) {
            if ((getStartDate().getTimeInMillis() == 0) && (getEndDate().getTimeInMillis() == 0)) {
                return true;
            }
        }
        return false;
    }

    private boolean isConvertEventToDeadline(boolean hasTaskChanged) {
        if (getStartDate() != null) {
            if ((getStartDate().getTimeInMillis() == 0) && (!hasTaskChanged)) {
                return true;
            }
        }
        return false;
    }

    /**
     * checks if there is a conversion of task type from float to event/deadline
     * and converts accordingly
     */
    private boolean hasChangeFloatTaskType(TaskFloat task) {
        boolean hasTaskChanged = false;
        if (isChangeFloatToEvent()) {
            _logger.log(Level.INFO, "Update: Convert float to event");
            convertFloatToEvent(task);
            hasTaskChanged = true;
        } else {
            if (isChangeFloatToDeadline()) {
                _logger.log(Level.INFO, "Update: Convert float to deadline");
                convertFloatToDeadline(task);
                hasTaskChanged = true;
            }
        }
        return hasTaskChanged;
    }

    private void convertFloatToDeadline(TaskFloat task) {
        Command addCommand = new CommandAddDeadlineTask(task.getDescription(), task.getLocation(),
                getEndDate(), task.getTags());
        _display = addCommand.execute(_display);
    }

    private boolean isChangeFloatToDeadline() {
        if (getEndDate() != null) {
            if (getEndDate().getTimeInMillis() != 0) {
                return true;
            }
        }
        return false;
    }

    private void convertFloatToEvent(TaskFloat task) {
        Command addCommand = new CommandAddEvent(task.getDescription(), task.getLocation(), getStartDate(),
                getEndDate(), task.getTags());
        _display = addCommand.execute(_display);
    }

    private boolean isChangeFloatToEvent() {
        if ((getStartDate() != null) && (getEndDate() != null)) {
            if ((getStartDate().getTimeInMillis() != 0) && (getEndDate().getTimeInMillis() != 0)) {
                return true;
            }
        }
        return false;
    }

    public boolean requiresSaveHistory() {
        return _saveHistory;
    }

    public boolean requiresUpdateFile() {
        return _updateFile;
    }
}
```
###### CS2103\src\entity\Display.java
``` java
 */
package entity;

/**
 * This class keeps track of all tasks and also the view state
 * of the program.
 * 
 */

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Calendar;

@SuppressWarnings("serial")
public class Display implements java.io.Serializable {

    private String _message;
    private String _commandType;
    private ArrayList<Integer> _taskIndices = new ArrayList<Integer>();
    private ArrayList<Integer> _conflictingTasksIndices = new ArrayList<Integer>();

    private ArrayList<TaskEvent> _events = new ArrayList<TaskEvent>();
    private ArrayList<TaskDeadline> _deadlineTasks = new ArrayList<TaskDeadline>();
    private ArrayList<TaskFloat> _floatTasks = new ArrayList<TaskFloat>();
    private ArrayList<TaskReserved> _reservedTasks = new ArrayList<TaskReserved>();
    private ArrayList<Task> _completedTasks = new ArrayList<Task>();

    private ArrayList<TaskEvent> _visibleEvents = _events;
    private ArrayList<TaskDeadline> _visibleDeadlineTasks = _deadlineTasks;
    private ArrayList<TaskFloat> _visibleFloatTasks = _floatTasks;
    private ArrayList<TaskReserved> _visibleReservedTasks = _reservedTasks;
    private ArrayList<Task> _visibleCompletedTasks = new ArrayList<Task>();

    public Display() {
        _message = GlobalConstants.EMPTY_STRING;
    }

    public Display(String message) {
        this._message = message;
    }

    public Display(String message, ArrayList<TaskEvent> events, ArrayList<TaskDeadline> deadlineTasks,
            ArrayList<TaskFloat> floatTasks, ArrayList<TaskReserved> reservedTasks,
            ArrayList<Task> completedTasks) {
        this._message = "";
        this._events = events;
        this._deadlineTasks = deadlineTasks;
        this._floatTasks = floatTasks;
        this._reservedTasks = reservedTasks;
        this._completedTasks = completedTasks;
        _visibleEvents = events;
        _visibleDeadlineTasks = deadlineTasks;
        _visibleFloatTasks = floatTasks;
        _visibleReservedTasks = reservedTasks;
    }

    public void setCommandType(String commandType) {
        this._commandType = commandType;
    }

    public String getCommandType() {
        return _commandType;
    }

    public void setConflictingTasksIndices(ArrayList<Integer> conflictingTasksIndices) {
        this._conflictingTasksIndices = conflictingTasksIndices;
    }

    public ArrayList<Integer> getConflictingTasksIndices() {
        return _conflictingTasksIndices;
    }

    public void setTaskIndices(ArrayList<Integer> taskIndices) {
        this._taskIndices = taskIndices;
    }

    public ArrayList<Integer> getTaskIndices() {
        return _taskIndices;
    }

    public void setVisibleReservedTasks(ArrayList<TaskReserved> reservedTasks) {
        this._visibleReservedTasks = reservedTasks;
    }

    public void setVisibleDeadlineTasks(ArrayList<TaskDeadline> deadlineTasks) {
        this._visibleDeadlineTasks = deadlineTasks;
    }

    public void setVisibleEvents(ArrayList<TaskEvent> events) {
        this._visibleEvents = events;
    }

    public void setVisibleFloatTasks(ArrayList<TaskFloat> floatTasks) {
        this._visibleFloatTasks = floatTasks;
    }

    public ArrayList<TaskFloat> getVisibleFloatTasks() {
        return _visibleFloatTasks;
    }

    public ArrayList<TaskEvent> getVisibleEvents() {
        return _visibleEvents;
    }

    public ArrayList<TaskDeadline> getVisibleDeadlineTasks() {
        return _visibleDeadlineTasks;
    }

    public ArrayList<TaskReserved> getVisibleReservedTasks() {
        return _visibleReservedTasks;
    }

    public void setMessage(String message) {
        this._message = message;
    }

    public int getNumberOfTasks() {
        return (_events.size() + _deadlineTasks.size() + _floatTasks.size() + _reservedTasks.size()
                + _completedTasks.size());
    }

    public String getMessage() {
        return _message;
    }

    public void setEvents(ArrayList<TaskEvent> events) {
        this._events = events;
    }

    public ArrayList<TaskEvent> getEventTasks() {
        return _events;
    }

    public void setDeadlineTasks(ArrayList<TaskDeadline> deadlineTasks) {
        this._deadlineTasks = deadlineTasks;
    }

    public ArrayList<TaskDeadline> getDeadlineTasks() {
        return _deadlineTasks;
    }

    public Display deepClone() {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(this);

            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bais);
            return (Display) ois.readObject();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public void setFloatTasks(ArrayList<TaskFloat> floatTasks) {
        this._floatTasks = floatTasks;
    }

    public ArrayList<TaskFloat> getFloatTasks() {
        return _floatTasks;
    }

    public void setReservedTasks(ArrayList<TaskReserved> reservedTasks) {
        this._reservedTasks = reservedTasks;
    }

    public ArrayList<TaskReserved> getReservedTasks() {
        return _reservedTasks;
    }

    public ArrayList<Task> getCompletedTasks() {
        return _completedTasks;
    }

    public void setCompletedTasks(ArrayList<Task> completedTasks) {
        this._completedTasks = completedTasks;
    }

    public ArrayList<Task> getVisibleCompletedTasks() {
        return _visibleCompletedTasks;
    }

    public void setVisibleCompletedTasks(ArrayList<Task> completedTasks) {
        this._visibleCompletedTasks = completedTasks;
    }

    public boolean setOverdueTasks() {
        boolean changed = false;
        changed = setOverdueDeadlines(changed);
        changed = setOverdueEvents(changed);
        return changed;
    }

    private boolean setOverdueDeadlines(boolean changed) {
        if (this.getDeadlineTasks() != null) {
            for (int i = 0; i < this.getDeadlineTasks().size(); i++) {
                TaskDeadline task = this.getDeadlineTasks().get(i);
                if (task.getEndDate().before(Calendar.getInstance())) {
                    if (!task.isOverdue()) {
                        task.setIsOverdue(true);
                        changed = true;
                    }
                }

            }
        }
        return changed;
    }

    private boolean setOverdueEvents(boolean changed) {
        if (this.getEventTasks() != null) {
            for (int i = 0; i < this.getEventTasks().size(); i++) {
                TaskEvent task = this.getEventTasks().get(i);
                if (task.getEndDate().before(Calendar.getInstance())) {
                    if (!task.isOverdue()) {
                        task.setIsOverdue(true);
                        changed = true;
                    }
                }

            }
        }
        return changed;
    }

```
###### CS2103\src\entity\GlobalConstants.java
``` java
package entity;

public class GlobalConstants {

    public static final String ALL_TASKS = "all tasks";
    public static final String AT = " at ";
    public static final String COMMA_SPACE = ", ";
    public static final String COMMA_SPACE_INVERTED_COMMAS = ", \"";
    public static final String CONTAINING = " containing ";
    public static final String DATE_FORMAT = "dd/MM/yy HH:mm";
    public static final String EMPTY_STRING = "";
    public static final String FROM = " from ";
    public static final String INVERTED_COMMAS = "\"";
    public static final String SPACE = " ";
    public static final String TAGGED = " tagged";
    public static final String TASKS = "tasks";
    public static final String TO = " to ";
    public static final String MINUTE = "minute";
    public static final String HOUR = "hour";
    public static final String DAY = "day";
    public static final String MONTH = "month";
    public static final String YEAR = "year";
    
    public static final String GUI_ANIMATION_ADD = "Add";
    public static final String GUI_ANIMATION_DELETE = "Delete";
    public static final String GUI_ANIMATION_INVALID = "Invalid";
    
    public static final String MESSAGE_ADD_SUCCESS = "added: \"%1$s\"";
    public static final String MESSAGE_ALL_COMPLETED = "All shown tasks completed";
    public static final String MESSAGE_ALL_DELETED = "All tasks deleted";
    public static final String MESSAGE_ALL_UNDONE = "All tasks undone";
    public static final String MESSAGE_CHANGE_FILEPATH = "File path changed to: ";
    public static final String MESSAGE_FILE_CREATED = "File created and ready for use";
    public static final String MESSAGE_FILE_PATH_CHANGE = "File path changed to: ";
    public static final String MESSAGE_NATTY = "add this due tmr 3pm";
    public static final String MESSAGE_REDO = "Redid command(s)";
    public static final String MESSAGE_RESERVED = "Reserved: \"%1$s\"";
    public static final String MESSAGE_NO_TASKS = "No such tasks found";
    public static final String MESSAGE_POSTPONED = "Postponed: ";
    public static final String MESSAGE_START_UP = "Welcome! These are today's agenda and overdue tasks.";
    public static final String MESSAGE_SHOW_ALL = "Displaying all tasks";
    public static final String MESSAGE_UNDO = "Undid previous commands";
    
    public static final String MESSAGE_ERROR_ADD_START_DATE_ONLY = "Can't add just the start date!!";
    public static final String MESSAGE_ERROR_ADD_START_REMOVE_END = "Cant add start date and remove end date!";
    public static final String MESSAGE_ERROR_CANT_CHANGE_FILEPATH = "Can't change filePath";
    public static final String MESSAGE_ERROR_DATE_RANGE = "Please specify a valid date range";
    public static final String MESSAGE_ERROR_DESCRIPTION = "Please enter a description";
    public static final String MESSAGE_ERROR_FILE_EXISTS = "File already exists";
    public static final String MESSAGE_ERROR_CHANGE_FILE_PATH = "Can't change filePath";
    public static final String MESSAGE_ERROR_INVALID_COMMAND = "You have specified an invalid command";
    public static final String MESSAGE_ERROR_INVALID_INDEX = "Please specify a valid index";
    public static final String MESSAGE_ERROR_INVALID_TIMESLOT = "Please specify a valid time slot";
    public static final String MESSAGE_ERROR_SPECIFY_BOTH_START_END = "Please specify both start and end dates";
    public static final String MESSAGE_ERROR_NO_LOCATION = "No location to remove!";
    public static final String MESSAGE_ERROR_NO_NUMBER = "please specify a task index";
    public static final String MESSAGE_ERROR_NO_RESERVED_TASKS = "There are no reserved tasks";
    public static final String MESSAGE_ERROR_NO_TAGS = "No tags to remove!";
    public static final String MESSAGE_ERROR_NO_TIMESLOT = "Please specify a time slot";
    public static final String MESSAGE_ERROR_NO_VISIBLE_RESERVED_TASKS = "There are no shown reserved tasks";
    public static final String MESSAGE_ERROR_POSTPONE_INVALID_TASK_TYPES = "You can only pospone deadline tasks and events!";
    public static final String MESSAGE_ERROR_READING_FILE = "Error occured while reading file";
    public static final String MESSAGE_ERROR_REDO = "You have reached the latest point possible";
    public static final String MESSAGE_ERROR_REMOVE_END = "Can't remove end date!";
    public static final String MESSAGE_ERROR_REMOVE_END_DATE_ONLY = "Cant remove end date only!";
    public static final String MESSAGE_ERROR_REMOVE_START = "Can't remove start date!";
    public static final String MESSAGE_ERROR_START_AFTER_END = "Start date must be before end date!";
    public static final String MESSAGE_ERROR_TASK_NUMBER = "Please specify a valid task number";
    public static final String MESSAGE_ERROR_TIME_RANGE = "You have entered invalid time range(s)";
    public static final String MESSAGE_ERROR_UNDO = "You have reached the earliest point possible";
    public static final String MESSAGE_ERROR_UPDATE_FILE = "Error occured while updating to file";
    public static final String TASK_TYPE_COMPLETED = "done";
    public static final String TASK_TYPE_DEADLINE = "deadline";
    public static final String TASK_TYPE_FLOAT = "untimed";
    public static final String TASK_TYPE_EVENT = "event";
    public static final String TASK_TYPE_RESERVED = "reserved";

    public static final int TIMER_REMINDER_PERIOD = 60;
    public static final int TIMER_PERIOD = 1000;
    public static final int TIMER_DELAY = 0;
    public static final boolean IS_DAEMON_TASK = true;
}
```
###### CS2103\src\entity\Task.java
``` java
 */
package entity;

import java.util.ArrayList;

@SuppressWarnings("serial")
public class Task implements java.io.Serializable {
	private String _description;
	private String _location;
	private ArrayList<String> _tags;
	private boolean _isOverdue;

```
###### CS2103\src\entity\Task.java
``` java
	public Task() {
		_description = null;
		_location = null;
		_tags = null;
	}

	public Task(String description, String location, ArrayList<String> tags) {
		this._description = description;
		this._location = location;
		this._tags = tags;
	}

	public void setIsOverdue(boolean isOverdue) {
		this._isOverdue = isOverdue;
	}

	public boolean isOverdue() {
		return _isOverdue;
	}

	public void setDescription(String description) {
		this._description = description;
	}

	public String getDescription() {
		return _description;
	}

	public void setTags(ArrayList<String> tags) {
		this._tags = tags;
	}

	public ArrayList<String> getTags() {
		return _tags;
	}

	public String getLocation() {
		return _location;
	}

	public void setLocation(String location) {
		this._location = location;
	}

```
###### CS2103\src\entity\TaskDeadline.java
``` java
 */
package entity;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

@SuppressWarnings("serial")
public class TaskDeadline extends Task {
	private Calendar _endDate;

```
###### CS2103\src\entity\TaskDeadline.java
``` java
	public TaskDeadline() {
		this.setDescription(null);
		this.setLocation(null);
		this.setTags(null);
		this._endDate = null;
	}

	public TaskDeadline(String description, String location, Calendar endDate, ArrayList<String> tags) {
		this.setDescription(description);
		this.setLocation(location);
		this.setTags(tags);
		this._endDate = endDate;
	}

	public void setEndDate(Calendar endDate) {
		this._endDate = endDate;
	}

	public Calendar getEndDate() {
		return _endDate;
	}

```
###### CS2103\src\entity\TaskEvent.java
``` java
 */
package entity;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

@SuppressWarnings("serial")
public class TaskEvent extends TaskDeadline {
	private Calendar _startDate;

```
###### CS2103\src\entity\TaskEvent.java
``` java
	public TaskEvent() {
		this.setDescription(null);
		this.setLocation(null);
		this.setTags(null);
		this.setEndDate(null);
		this._startDate = null;
	}

	public TaskEvent(String description, String location, Calendar startDate, Calendar endDate,
			ArrayList<String> tags) {
		this.setDescription(description);
		this.setLocation(location);
		this.setTags(tags);
		this.setEndDate(endDate);
		this._startDate = startDate;
	}

	public void setStartDate(Calendar startDate) {
		this._startDate = startDate;
	}

	public Calendar getStartDate() {
		return _startDate;
	}

```
###### CS2103\src\entity\TaskFloat.java
``` java
 */
package entity;

import java.util.ArrayList;

@SuppressWarnings("serial")
public class TaskFloat extends Task {
```
###### CS2103\src\entity\TaskFloat.java
``` java
	public TaskFloat() {
		super();
	}

	public TaskFloat(String description, String location, ArrayList<String> tags) {
		super(description, location, tags);
	}

```
###### CS2103\src\entity\TaskReserved.java
``` java
 */

package entity;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;

@SuppressWarnings("serial")
public class TaskReserved extends Task {
	private ArrayList<Calendar> _startDates;
	private ArrayList<Calendar> _endDates;

```
###### CS2103\src\entity\TaskReserved.java
``` java
	public TaskReserved() {
		this.setDescription(null);
		this.setLocation(null);
		this.setTags(null);
		_startDates = null;
		_endDates = null;
	}

	public TaskReserved(String description, String location, ArrayList<Calendar> startDates,
			ArrayList<Calendar> endDates, ArrayList<String> tags) {
		this.setDescription(description);
		this.setLocation(location);
		this.setTags(tags);
		this._startDates = startDates;
		this._endDates = endDates;
	}

	public void setStartDates(ArrayList<Calendar> startDates) {
		this._startDates = startDates;
	}

	public ArrayList<Calendar> getStartDates() {
		return _startDates;
	}

	public void setEndDates(ArrayList<Calendar> endDates) {
		this._endDates = endDates;
	}

	public ArrayList<Calendar> getEndDates() {
		return _endDates;
	}

```
###### CS2103\src\history\History.java
``` java
 */
package history;

/**
 * This class stores the "states" of the display for
 * undo/redo command
 */
import java.util.ArrayList;

import entity.Display;

public class History {

    private static ArrayList<Display> _oldDisplays = new ArrayList<Display>();
    private static int _oldDisplaysIndex = -1;

    /*
     * removes any unwanted states before 
     * saving a new display state.
     */
    public static void saveDisplay(Display display) {
        if (_oldDisplaysIndex < (_oldDisplays.size() - 1)) {
            for (int i = (_oldDisplays.size() - 1); i > _oldDisplaysIndex; i--) {
                _oldDisplays.remove(i);
            }
        }
        _oldDisplays.add(display);
        _oldDisplaysIndex++;
    }

    public static boolean atLastState() {
        return (_oldDisplaysIndex == (_oldDisplays.size() - 1));
    }

    public static boolean atFirstState() {
        return (_oldDisplaysIndex == 0);
    }

    /*
     * Gets the display state specified by the offset
     */
    public static Display getDisplay(int offset) {
        if (offset > 0) {
            if (atLastState()) {
                return null;
            }
            _oldDisplaysIndex += offset;
            if (indexOutOfRange()) {
                _oldDisplaysIndex = _oldDisplays.size() - 1;
            }
        } else if (offset < 0) {
            if (atFirstState()) {
                return null;
            }
            _oldDisplaysIndex += offset;
            if (_oldDisplaysIndex < 0) {
                _oldDisplaysIndex = 0;
            }
        }
        return _oldDisplays.get(_oldDisplaysIndex);
    }

    private static boolean indexOutOfRange() {
        return _oldDisplaysIndex > (_oldDisplays.size() - 1);
    }

}
```
###### CS2103\src\logic\Logic.java
``` java
 */
package logic;
/**
 * This class serves as the interface between ui and 
 * the sub components. 
 */
import history.History;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Timer;
import java.util.logging.Level;
import java.util.logging.Logger;

import entity.Command;
import entity.CommandShow;
import entity.Display;
import entity.GlobalConstants;
import entity.GlobalLogger;
import parser.JListeeParser;
import storage.Storage;

public class Logic {
    private static Storage _storage = Storage.getInstance();
    private static Display _display;
    private static String _file;
    private static Logger _logger = GlobalLogger.getLogger();

    /*
     * call storage to create text file specified by the filepath
     */
    public static boolean createFile(String filePath) {
        _logger.log(Level.INFO, "Logic: Create filepath " + filePath);
        _file = filePath;
        try {
            _storage.createFile(filePath);
            return true;
        } catch (IOException error) {
            return false;
        }
    }

    /*
     * call storage to change the file path of text file
     */
    public static Display changeFilePath(String filePath) {
        _logger.log(Level.INFO, "Logic: Change filepath" + filePath);
        try{
        	_file = filePath;
            _storage.changeFilePath(filePath);
            initializeDisplay();
            _display.setMessage(GlobalConstants.MESSAGE_FILE_PATH_CHANGE + filePath);
        }catch(IOException e){
            _display.setMessage(GlobalConstants.MESSAGE_ERROR_CHANGE_FILE_PATH);
        }
        return _display;
    }

    /*
     * sets up the program on first start up of the program
     */
    public static Display initializeProgram(String filePath) {
        _logger.log(Level.INFO, "Logic: Initialise Program" + filePath);
        _file = filePath;
        initializeDisplay();
        initialiseOverdueTasksReminder();
        synchronized (_display) {
            History.saveDisplay(_display.deepClone());
        }
        initialiseNatty();
        return _display;
    }

    /*
     * initialise the timertask to constantly poll
     * for overdue tasks
     */
    private static void initialiseOverdueTasksReminder() {
        Timer timer = new Timer(GlobalConstants.IS_DAEMON_TASK);
        timer.schedule(new ReminderOverdue(), GlobalConstants.TIMER_DELAY, GlobalConstants.TIMER_PERIOD);
    }

    /*
     * display is set to show only overdue and today's task on startup
     */
    private static void initializeDisplay() {
        _display = getDisplayFromStorage();
        Calendar start = Calendar.getInstance();
        start.setTimeInMillis(0);
        Calendar end = Calendar.getInstance();
        end.set(Calendar.HOUR_OF_DAY, 23);
        end.set(Calendar.MINUTE, 59);
        _display = new CommandShow(null, null, start, end, new ArrayList<String>()).execute(_display);
        _display.setMessage(GlobalConstants.MESSAGE_START_UP);
    }

    /*
     * called by ui whenever user enters a command and
     * executes it
     */
    public static Display executeUserCommand(String userInput) {
        _logger.log(Level.INFO, "Logic: Parsing user input " + userInput);
        Command userCommand = parseUserInput(userInput);
        assert userCommand != null: "Null Command";
        synchronized (_display) {
            _display = executeCommand(userCommand);
        }
        return _display;
    }

    private static void saveDisplayToHistory(Command userCommand) {
        if (userCommand.requiresSaveHistory()) {
            History.saveDisplay(_display.deepClone());
        }
    }

    public static Display getDisplay() {
        return _display;
    }

    public static Display executeCommand(Command userCommand) {
        _logger.log(Level.INFO, "Logic: Executing command ");
        _display = userCommand.execute(_display);

        if (requiresFileUpdate(userCommand)) {
            if (successfullyUpdatesFile()) {
                saveDisplayToHistory(userCommand);
            } else {
                _display.setMessage(GlobalConstants.MESSAGE_ERROR_UPDATE_FILE);
            }
        } else {
            saveDisplayToHistory(userCommand);
        }
        return _display;
    }

    private static boolean requiresFileUpdate(Command userCommand) {
        return userCommand.requiresUpdateFile();
    }

    private static Command parseUserInput(String userInput) {
        JListeeParser myParser = new JListeeParser();
        Command userCommand = myParser.ParseCommand(userInput);
        return userCommand;
    }

    private static Display getDisplayFromStorage() {
        Display thisDisplay = null;
        try {
            thisDisplay = _storage.getDisplay(_file);
            assert thisDisplay != null: "Logic: Null display from storage";
        } catch (IOException e) {
            e.printStackTrace();
        }
        return thisDisplay;
    }

    private static boolean successfullyUpdatesFile() {
        try {
            _storage.saveFile(_display);
            return true;
        } catch (IOException error) {
            return false;
        }
    }

    private static void initialiseNatty() {
        JListeeParser myParser = new JListeeParser();
        myParser.ParseCommand(GlobalConstants.MESSAGE_NATTY);
    }
}
```
###### CS2103\src\logic\ReminderOverdue.java
``` java
 */
package logic;

/**
 * This class employs multithreading to poll for
 * overdue tasks and reminds user if there is a
 * task that has just became overdue
 */
import java.util.Calendar;
import java.util.TimerTask;
import java.util.logging.Level;
import java.util.logging.Logger;

import entity.Display;
import entity.GlobalConstants;
import entity.GlobalLogger;
import gui.GUIController;
import javafx.application.Platform;

public class ReminderOverdue extends TimerTask {
    private String message_overdue = "You have overdue tasks!";
    private boolean changeInOverdue = false;
    private int minute = Calendar.getInstance().get(Calendar.MINUTE);
    private Logger logger = GlobalLogger.getLogger();

    public ReminderOverdue() {
    }

    @Override
    public void run() {
        Platform.runLater(new Runnable() {
            public void run() {
                Display display = Logic.getDisplay();
                assert display != null: "Reminder: null display";
                synchronized (display) {
                    changeInOverdue = display.setOverdueTasks();
                    if (notifyUserOfOverdueTasks()) {
                        logger.log(Level.INFO, "Reminder: Notify user of overdue tasks");
                        display.setCommandType(GlobalConstants.GUI_ANIMATION_INVALID);
                        display.setMessage(message_overdue);
                        GUIController.displayList(display);
                        minute = Calendar.getInstance().get(Calendar.MINUTE);
                    }

                }
            }
        });
    }

    private boolean notifyUserOfOverdueTasks() {
        if (Calendar.getInstance().get(Calendar.MINUTE) != minute) {
            if (changeInOverdue) {
                return true;
            }
        }
        return false;
    }
}
```
###### CS2103\src\tests\LogicTest.java
``` java
 */
package tests;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;
import java.util.Calendar;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import entity.CommandAddDeadlineTask;
import entity.CommandAddEvent;
import entity.CommandAddFloatTask;
import entity.CommandAddReserved;
import entity.CommandDelete;
import entity.CommandDone;
import entity.CommandInvalid;
import entity.CommandPostpone;
import entity.CommandRedo;
import entity.CommandShow;
import entity.CommandUndo;
import entity.CommandUndone;
import entity.CommandUpdate;
import logic.Logic;

public class LogicTest {
    private String filepath = "src\\tests\\integrationTest.txt";

    @Before
    public void createTestFile() {
        Logic.createFile(filepath);
        Logic.initializeProgram(filepath);
    }

    @After
    public void deleteTestFile() {
        File testFile = new File(filepath);
        testFile.delete();
    }

    @Test
    public void test() {
        // clear display
        // show all
        Logic.executeCommand(new CommandShow(null, null, null, null, null));
        // delete all
        assertEquals(
                "Display [message=All tasks deleted, events=[], deadlineTasks=[], "
                        + "floatTasks=[], reservedTasks=[], completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(null)).toString());
        // show done
        ArrayList<String> types = new ArrayList<String>();
        types.add("done");
        Logic.executeCommand(new CommandShow(null, null, null, null, null, types));
        // delete all
        assertEquals(
                "Display [message=All tasks deleted, events=[], deadlineTasks=[], "
                        + "floatTasks=[], reservedTasks=[], completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(null)).toString());
        // show all
        assertEquals(
                "Display [message=Displaying all tasks, events=[], deadlineTasks=[], "
                        + "floatTasks=[], reservedTasks=[], completedTasks=[]]",
                Logic.executeCommand(new CommandShow(null, null, null, null, null)).toString());
        ArrayList<String> tags = new ArrayList<String>();

        // add float task without location and tags
        assertEquals(
                "Display [message=added: \"Float1\", events=[], deadlineTasks=[], "
                        + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                        + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("Float1", "", tags)).toString());

        // undo after entering command
        assertEquals(
                "Display [message=Undid previous commands, events=[], deadlineTasks=[], "
                        + "floatTasks=[], reservedTasks=[], completedTasks=[]]",
                Logic.executeCommand(new CommandUndo()).toString());

        // redo after undo
        assertEquals("Display [message=Redid command(s), events=[], deadlineTasks=[], "
                + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                + "completedTasks=[]]", Logic.executeCommand(new CommandRedo()).toString());

        // redo at latest state
        assertEquals(
                "Display [message=You have reached the latest point possible, events=[], deadlineTasks=[], "
                        + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                        + "completedTasks=[]]",
                Logic.executeCommand(new CommandRedo()).toString());

        // add float task without description
        assertEquals(
                "Display [message=Please enter a description, events=[], deadlineTasks=[], "
                        + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                        + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("", "", tags)).toString());

        // add float task with location
        assertEquals("Display [message=added: \"Float2\", events=[], deadlineTasks=[], " + "floatTasks=["
                + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("Float2", "jcube", tags)).toString());

        tags = new ArrayList<String>();
        // add float task with tag
        tags.add("tag1");
        assertEquals("Display [message=added: \"Float3\", events=[], deadlineTasks=[], " + "floatTasks=["
                + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("Float3", "", tags)).toString());

        // add float task with multiple tags
        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        tags.add("tag4");
        tags.add("tag5");
        assertEquals("Display [message=added: \"Float4\", events=[], deadlineTasks=[], " + "floatTasks=["
                + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("Float4", "", tags)).toString());

        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        tags.add("tag4");
        tags.add("tag5");
        // add float task with location and multiple tags
        assertEquals("Display [message=added: \"Float5\", events=[], deadlineTasks=[], " + "floatTasks=["
                + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddFloatTask("Float5", "location", tags)).toString());

        // add deadline task without location and tag
        tags = new ArrayList<String>();
        Calendar end = Calendar.getInstance();
        end.set(2016, 2 - 1, 19, 19, 00);
        assertEquals(
                "Display [message=added: \"DL1\", events=[], " + "deadlineTasks=[" + "Description: DL1\r\n"
                        + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "

                        + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                        + ", Description: Float4\r\n" + "Location: \r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                        + ", Description: Float5\r\n" + "Location: location\r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                        + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddDeadlineTask("DL1", "", end, tags)).toString());

        // add deadline task with location and has due date before previously
        // added deadline task
        end = Calendar.getInstance();
        end.set(2016, 2 - 1, 19, 14, 00);
        assertEquals(
                "Display [message=added: \"DL2\", events=[], " + "deadlineTasks=[" + "Description: DL2\r\n"
                        + "Deadline: 19/02/16 14:00\r\n" + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                        + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                        + "Tags:\r\n\r\n], "

                        + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                        + ", Description: Float4\r\n" + "Location: \r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                        + ", Description: Float5\r\n" + "Location: location\r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                        + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddDeadlineTask("DL2", "JEM", end, tags)).toString());

        // add deadline task with tag with due dates between 2 previous added
        // deadline tasks
        end = Calendar.getInstance();
        tags = new ArrayList<String>();
        end.set(2016, 2 - 1, 19, 15, 00);
        tags.add("tag1");
        assertEquals(
                "Display [message=added: \"DL3\", events=[], " + "deadlineTasks=[" + "Description: DL2\r\n"
                        + "Deadline: 19/02/16 14:00\r\n" + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                        + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                        + "Tags: #tag1\r\n\r\n, "

                        + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                        + "Tags:\r\n\r\n], "

                        + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                        + ", Description: Float4\r\n" + "Location: \r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                        + ", Description: Float5\r\n" + "Location: location\r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                        + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddDeadlineTask("DL3", "", end, tags)).toString());

        // add deadline task with multiple tags and location
        end = Calendar.getInstance();
        tags = new ArrayList<String>();
        end.set(2016, 2 - 1, 19, 15, 00);
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        assertEquals(
                "Display [message=added: \"DL4\", events=[], " + "deadlineTasks=[" + "Description: DL2\r\n"
                        + "Deadline: 19/02/16 14:00\r\n" + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                        + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                        + "Tags: #tag1\r\n\r\n, "

                        + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                        + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                        + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                        + "Tags:\r\n\r\n], "

                        + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                        + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                        + ", Description: Float4\r\n" + "Location: \r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                        + ", Description: Float5\r\n" + "Location: location\r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                        + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddDeadlineTask("DL4", "JEM", end, tags)).toString());

        // add event without tag and location
        Calendar start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 12, 00);
        end.set(2016, 2 - 1, 19, 15, 00);
        tags = new ArrayList<String>();

        assertEquals("Display [message=added: \"Event1\", " + "events=[" + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n" + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL2\r\n" + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddEvent("Event1", "", start, end, tags)).toString());

        // add event with location before previously added event
        end = Calendar.getInstance();
        start = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 00);
        end.set(2016, 2 - 1, 19, 16, 00);
        tags = new ArrayList<String>();

        assertEquals("Display [message=added: \"Event2\", " + "events=["

                + "Description: Event2\r\n" + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL2\r\n" + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddEvent("Event2", "jcube", start, end, tags)).toString());

        // add event with tags before between 2 previously added events
        tags = new ArrayList<String>();
        end = Calendar.getInstance();
        start = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 30);
        end.set(2016, 2 - 1, 19, 16, 00);
        tags.add("tag1");

        assertEquals("Display [message=added: \"Event3\", " + "events=["

                + "Description: Event2\r\n" + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL2\r\n" + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddEvent("Event3", "", start, end, tags)).toString());

        // delete a task
        ArrayList<Integer> delNum = new ArrayList<Integer>();
        delNum.add(9);

        assertEquals("Display [message=deleted: \"Float2\", " + "events=["

                + "Description: Event2\r\n" + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: jcube\r\n" + "Tags:\r\n\r\n"

                + ", Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL2\r\n" + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n" + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(delNum)).toString());

        // delete multiple tasks
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        delNum.add(5);

        assertEquals("Display [message=deleted: \"DL2\", \"Event2\", " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(delNum)).toString());

        // delete invalid task
        delNum = new ArrayList<Integer>();
        delNum.add(0);

        assertEquals("Display [message=You have specified invalid numbers: 0, " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(delNum)).toString());

        // delete multiple tasks with valid and invalid task numbers
        delNum = new ArrayList<Integer>();
        delNum.add(0);
        delNum.add(-1);
        delNum.add(3);

        assertEquals("Display [message=You have specified invalid numbers: 0, -1, " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandDelete(delNum)).toString());

        // user enters invalid command
        assertEquals("Display [message=You have specified an invalid command, " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], " + "completedTasks=[]]",
                Logic.executeCommand(new CommandInvalid()).toString());

        // user reserves time slot
        tags = new ArrayList<String>();
        ArrayList<Calendar> startDates = new ArrayList<Calendar>();
        ArrayList<Calendar> endDates = new ArrayList<Calendar>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 30);
        end.set(2016, 2 - 1, 19, 16, 00);
        startDates.add(start);
        endDates.add(end);
        assertEquals("Display [message=Reserved: \"r1\", " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "
                + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddReserved("r1", "", startDates, endDates, tags))
                        .toString());

        // user reserves multiple time slots with tags and location
        tags = new ArrayList<String>();
        startDates = new ArrayList<Calendar>();
        endDates = new ArrayList<Calendar>();
        Calendar start1 = Calendar.getInstance();
        Calendar end1 = Calendar.getInstance();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 12, 00);
        end.set(2016, 2 - 1, 19, 15, 00);
        start1.set(2016, 2 - 1, 19, 11, 30);
        end1.set(2016, 2 - 1, 19, 16, 00);
        startDates.add(start);
        endDates.add(end);
        startDates.add(start1);
        endDates.add(end1);
        tags.add("tag1");
        tags.add("tag2");
        assertEquals("Display [message=Reserved: \"r2\", " + "events=["

                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandAddReserved("r2", "location", startDates, endDates, tags))
                        .toString());

        // show tasks containing 'l'
        assertEquals("Display [message=Displaying all tasks containing l, " + "events=[]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[], "

                + "completedTasks=[]]", Logic.executeCommand(new CommandShow("l")).toString());// show
                                                                                               // tasks
                                                                                               // containing
                                                                                               // 'l'

        // show tasks at specified location
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks at location, " + "events=[]"

                + ", deadlineTasks=[], "

                + "floatTasks=[" + "Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "location", null, null, tags)).toString());

        // show a time range
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 12, 00);
        end.set(2016, 2 - 1, 19, 15, 00);

        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 12:00 to 19/02/16 15:00, "
                + "events=[" + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());

        // show a time range where time is equal to task start/end time
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 30);
        end.set(2016, 2 - 1, 19, 12, 00);

        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 11:30 to 19/02/16 12:00, "
                + "events=[" + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());

        // show a time range
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 30);
        end.set(2016, 2 - 1, 19, 11, 59);

        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 11:30 to 19/02/16 11:59, "
                + "events=[" + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n]"

                + ", deadlineTasks=[], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());

        // show tag
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        tags.add("tag1");
        assertEquals("Display [message=Displaying all tasks tagged tag1, " + "events=["
                + "Description: Event3\r\n" + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());

        // show tag
        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        assertEquals("Display [message=Displaying all tasks tagged tag1, tag2, " + "events=[]"

                + ", deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "

                + "floatTasks=[" + "Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());

        // show tasks containing keyword, tags and is within time range
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 30);
        end.set(2016, 2 - 1, 19, 12, 00);
        assertEquals(
                "Display [message=Displaying all tasks containing l at location from 19/02/16 11:30 to 19/02/16 12:00 tagged tag1, tag2, "
                        + "events=[]"

                        + ", deadlineTasks=[], "

                        + "floatTasks=[" + "Description: Float5\r\n" + "Location: location\r\n"
                        + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                        + ", reservedTasks=[], "

                        + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("l", "location", start, end, tags)).toString());

        // show all
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks, " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float4\r\n" + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());

        // update Float task description, add location, remove tags and add tags
        ArrayList<String> removedTags = new ArrayList<String>();
        removedTags.add("tag3");
        removedTags.add("tag4");
        tags = new ArrayList<String>();
        tags.add("tag10");
        assertEquals("Display [message=Edited : \"Float4\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Floatter\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]", Logic
                        .executeCommand(
                                new CommandUpdate(8, "Floatter", "location", null, null, tags, removedTags))
                        .toString());

        // update Float task remove location, add due date
        removedTags = new ArrayList<String>();
        tags = new ArrayList<String>();
        end = Calendar.getInstance();
        end.set(2016, 2 - 1, 19, 12, 00);
        assertEquals("Display [message=Edited : \"Floatter\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: Floatter\r\n" + "Deadline: 19/02/16 12:00\r\n"
                + "Location: \r\n" + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(8, "", "", null, end, tags, removedTags)).toString());

        // update Float task add start and end time
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 45);
        end.set(2016, 2 - 1, 19, 13, 00);
        assertEquals("Display [message=Edited : \"Float1\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Float1\r\n" + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: Floatter\r\n" + "Deadline: 19/02/16 12:00\r\n"
                + "Location: \r\n" + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(7, null, null, start, end, tags, removedTags))
                        .toString());

        // update Deadline task description, add location, remove tags and add
        // tags
        removedTags = new ArrayList<String>();
        removedTags.add("tag1");
        tags = new ArrayList<String>();
        tags.add("tag11");

        assertEquals("Display [message=Edited : \"Floatter\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Float1\r\n" + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DeadlineTask\r\n" + "Deadline: 19/02/16 12:00\r\n"
                + "Location: location\r\n" + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(
                        new CommandUpdate(1, "DeadlineTask", "location", null, null, tags, removedTags))
                        .toString());

        // update Deadline due date and remove invalid task
        removedTags = new ArrayList<String>();
        removedTags.add("tag1");
        end = Calendar.getInstance();
        end.set(2016, 2 - 1, 19, 13, 00);

        assertEquals("Display [message=Edited : \"DeadlineTask\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Float1\r\n" + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DeadlineTask\r\n" + "Deadline: 19/02/16 13:00\r\n"
                + "Location: location\r\n" + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n, "

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(1, null, null, null, end, null, removedTags))
                        .toString());

        // update Deadline- remove due date
        end = Calendar.getInstance();
        end.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"DeadlineTask\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Float1\r\n" + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n"

                + ", Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=["

                + "Description: DL3\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(1, null, null, null, end, null, null)).toString());

        // update Deadline- add start date and change end date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 11, 45);
        end.set(2016, 2 - 1, 19, 14, 00);

        assertEquals("Display [message=Edited : \"DL3\", " + "events=[" + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n" + "End Date: 19/02/16 16:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Float1\r\n" + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(1, null, null, start, end, null, null)).toString());

        // update event start and end dates
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016, 2 - 1, 19, 13, 00);
        end.set(2016, 2 - 1, 19, 18, 00);

        assertEquals("Display [message=Edited : \"Event3\", " + "events=[" + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: Event3\r\n" + "Start Date: 19/02/16 13:00\r\n"
                + "End Date: 19/02/16 18:00\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n]"

                + ", deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(3, null, null, start, end, null, null)).toString());

        // update event - remove start date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"Event3\", " + "events=[" + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 13:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n" + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "

                + "deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(6, null, null, start, null, null, null)).toString());

        // update event - remove start and end date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.setTimeInMillis(0);
        end.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"Float1\", " + "events=[" + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "

                + "deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"

                + ", Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]",
                Logic.executeCommand(new CommandUpdate(4, null, null, start, end, null, null)).toString());

        // mark a task as done

        delNum = new ArrayList<Integer>();
        delNum.add(1);
        assertEquals("Display [message=Completed: \"DL4\", " + "events=[" + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "

                + "deadlineTasks=["

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"

                + ", Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]", Logic.executeCommand(new CommandDone(delNum)).toString());

        // mark multiple tasks as done
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        delNum.add(2);
        assertEquals("Display [message=Completed: \"Event3\", \"DL1\", " + "events=[" + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n" + "End Date: 19/02/16 14:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: Event1\r\n" + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n], "

                + "deadlineTasks=[], "

                + "floatTasks=[" + "Description: Float3\r\n" + "Location: \r\n" + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: DeadlineTask\r\n" + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"

                + ", Description: Float1\r\n" + "Location: \r\n" + "Tags:\r\n\r\n]"

                + ", reservedTasks=[" + "Description: r1\r\n" + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n" + "Location: \r\n" + "Tags:\r\n\r\n, "

                + "Description: r2\r\n" + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n" + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "

                + "completedTasks=[]]", Logic.executeCommand(new CommandDone(delNum)).toString());

        // show done
        types = new ArrayList<String>();
        types.add("done");
        assertEquals("Display [message=Displaying done tasks, " + "events=[], "

                + "deadlineTasks=[], "

                + "floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n]" + "]",
                Logic.executeCommand(new CommandShow(null, null, null, null, null, types)).toString());

        // undone task
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        assertEquals("Display [message=Undone task: \"DL4\", " + "events=[], "

                + "deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n" + "],"

                + " floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n]" + "]", Logic.executeCommand(new CommandUndone(delNum)).toString());

        // undone multiple task
        delNum = new ArrayList<Integer>();
        delNum.add(3);
        delNum.add(2);
        assertEquals("Display [message=Undone task: \"Event3\", \"DL1\", " + "events=[], "

                + "deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n" + ", "

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "]]", Logic.executeCommand(new CommandUndone(delNum)).toString());

        // done all
        assertEquals("Display [message=All shown tasks completed, " + "events=[], "

                + "deadlineTasks=[], "

                + "floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "]]", Logic.executeCommand(new CommandDone(null)).toString());

        // show done
        types = new ArrayList<String>();
        types.add("done");
        Logic.executeCommand(new CommandShow(null, null, null, null, null, types));
        // undone all
        assertEquals("Display [message=All tasks undone, " + "events=[], "

                + "deadlineTasks=[" + "Description: DL4\r\n" + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n" + "Tags: #tag1 #tag2 #tag3\r\n\r\n" + ", "

                + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n" + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n], "

                + "floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "]]", Logic.executeCommand(new CommandUndone(null)).toString());

        // postpone task
        start = Calendar.getInstance();
        start.set(Calendar.HOUR_OF_DAY, 2);
        start.set(Calendar.DATE, 2);
        start.set(Calendar.MINUTE, 2);
        start.set(Calendar.MONTH, 2);
        ArrayList<String> para = new ArrayList<String>();
        para.add("hour");
        para.add("day");
        para.add("minute");
        para.add("month");
        assertEquals("Display [message=Postponed: DL4, " + "events=[], "

                + "deadlineTasks=[" + "Description: Event3\r\n" + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n" + "Tags: #tag1\r\n\r\n, "

                + "Description: DL1\r\n" + "Deadline: 19/02/16 19:00\r\n" + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL4\r\n" + "Deadline: 21/04/16 17:02\r\n" + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n" + "], "

                + "floatTasks=[]"

                + ", reservedTasks=[], "

                + "completedTasks=[" + "]]",
                Logic.executeCommand(new CommandPostpone(1, start, para)).toString());

    }

}
```
###### CS2103\src\tests\LogicTest2.java
``` java
 */
package tests;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Before;
import org.junit.Test;

import entity.CommandAddDeadlineTask;
import entity.CommandAddEvent;
import entity.CommandAddFloatTask;
import entity.CommandAddReserved;
import entity.CommandDelete;
import entity.CommandDone;
import entity.CommandInvalid;
import entity.CommandPostpone;
import entity.CommandRedo;
import entity.CommandShow;
import entity.CommandUndo;
import entity.CommandUndone;
import entity.CommandUpdate;
import logic.Logic;

public class LogicTest2 {
    @Before
    public void startApp() {
        String args[] = null;
        main.App.main(args);
    }
    @Test
    public void test() {
        //undo when no commands entered yet
        //assertEquals("Display [message=You have reached the earliest point possible, events=[], deadlineTasks=[], "
        //        + "floatTasks=[], reservedTasks=[], completedTasks=[]]", 
         //       Logic.executeCommand(new CommandUndo()).toString());
        
        //clear display
        //show all
        Logic.executeCommand(new CommandShow(null, null, null, null, null));
        //delete all
        assertEquals("Display [message=All tasks deleted, events=[], deadlineTasks=[], "
                + "floatTasks=[], reservedTasks=[], completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(null)).toString());
        //show done
        ArrayList<String> types = new ArrayList<String>();
        types.add("done");
        Logic.executeCommand(new CommandShow(null, null, null, null, null,types));
        //delete all
        assertEquals("Display [message=All tasks deleted, events=[], deadlineTasks=[], "
                + "floatTasks=[], reservedTasks=[], completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(null)).toString());
        //show all
        assertEquals("Display [message=Displaying all tasks, events=[], deadlineTasks=[], "
                + "floatTasks=[], reservedTasks=[], completedTasks=[]]", 
                Logic.executeCommand(new CommandShow(null, null, null, null, null)).toString());
        ArrayList<String> tags = new ArrayList<String>();

        //add float task without location and tags
        assertEquals("Display [message=added: \"Float1\", events=[], deadlineTasks=[], "
                + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("Float1", "", tags)).toString());
        
        //undo after entering command
        assertEquals("Display [message=Undid previous commands, events=[], deadlineTasks=[], "
                + "floatTasks=[], reservedTasks=[], completedTasks=[]]", 
                Logic.executeCommand(new CommandUndo()).toString());

        //redo after undo
        assertEquals("Display [message=Redid command(s), events=[], deadlineTasks=[], "
                + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandRedo()).toString());

        //redo at latest state
        assertEquals("Display [message=You have reached the latest point possible, events=[], deadlineTasks=[], "
                + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandRedo()).toString());
        
        //add float task without description
        assertEquals("Display [message=Please enter a description, events=[], deadlineTasks=[], "
                + "floatTasks=[Description: Float1\r\nLocation: \r\nTags:\r\n\r\n], reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("", "", tags)).toString());
        
        //add float task with location
        assertEquals("Display [message=added: \"Float2\", events=[], deadlineTasks=[], "
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("Float2", "jcube", tags)).toString());

        tags = new ArrayList<String>();
        //add float task with tag
        tags.add("tag1");
        assertEquals("Display [message=added: \"Float3\", events=[], deadlineTasks=[], "
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("Float3", "", tags)).toString());

        //add float task with multiple tags
        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        tags.add("tag4");
        tags.add("tag5");
        assertEquals("Display [message=added: \"Float4\", events=[], deadlineTasks=[], "
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("Float4", "", tags)).toString());

        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        tags.add("tag4");
        tags.add("tag5");
        //add float task with location and multiple tags
        assertEquals("Display [message=added: \"Float5\", events=[], deadlineTasks=[], "
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddFloatTask("Float5", "location", tags)).toString());
        
        //add deadline task without location and tag
        tags = new ArrayList<String>();
        Calendar end = Calendar.getInstance();
        end.set(2016,2-1,19,19,00);
        assertEquals("Display [message=added: \"DL1\", events=[], "
                + "deadlineTasks=["
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddDeadlineTask("DL1", "", end, tags)).toString());
        
        //add deadline task with location and has due date before previously added deadline task
        end = Calendar.getInstance();
        end.set(2016,2-1,19,14,00);
        assertEquals("Display [message=added: \"DL2\", events=[], "
                + "deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddDeadlineTask("DL2", "JEM", end, tags)).toString());
        
        //add deadline task with tag with due dates between 2 previous added deadline tasks
        end = Calendar.getInstance();
        tags = new ArrayList<String>();
        end.set(2016,2-1,19,15,00);
        tags.add("tag1");
        assertEquals("Display [message=added: \"DL3\", events=[], "
                + "deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddDeadlineTask("DL3", "", end, tags)).toString());
        
        //add deadline task with multiple tags and location
        end = Calendar.getInstance();
        tags = new ArrayList<String>();
        end.set(2016,2-1,19,15,00);
        tags.add("tag1");
        tags.add("tag2");
        tags.add("tag3");
        assertEquals("Display [message=added: \"DL4\", events=[], "
                + "deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddDeadlineTask("DL4", "JEM", end, tags)).toString());
        
        //add event without tag and location
        Calendar start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,12,00);
        end.set(2016,2-1,19,15,00);
        tags = new ArrayList<String>();
        
        assertEquals("Display [message=added: \"Event1\", "
                + "events=["
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddEvent("Event1", "", start, end, tags)).toString());
        
        //add event with location before previously added event
        end = Calendar.getInstance();
        start = Calendar.getInstance();
        start.set(2016,2-1,19,11,00);
        end.set(2016,2-1,19,16,00);
        tags = new ArrayList<String>();
        
        assertEquals("Display [message=added: \"Event2\", "
                + "events=["

                + "Description: Event2\r\n"
                + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddEvent("Event2", "jcube", start, end, tags)).toString());
        
        //add event with tags before between 2 previously added events
        tags = new ArrayList<String>();
        end = Calendar.getInstance();
        start = Calendar.getInstance();
        start.set(2016,2-1,19,11,30);
        end.set(2016,2-1,19,16,00);
        tags.add("tag1");
        
        assertEquals("Display [message=added: \"Event3\", "
                + "events=["

                + "Description: Event2\r\n"
                + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float2\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"

                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddEvent("Event3", "", start, end, tags)).toString());
        
        //delete a task
        ArrayList<Integer> delNum = new ArrayList<Integer>();
        delNum.add(9);
        
        assertEquals("Display [message=deleted: \"Float2\", "
                + "events=["

                + "Description: Event2\r\n"
                + "Start Date: 19/02/16 11:00\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: jcube\r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL2\r\n"
                + "Deadline: 19/02/16 14:00\r\n"
                + "Location: JEM\r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(delNum)).toString());
        
        //delete multiple tasks
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        delNum.add(5);
        
        assertEquals("Display [message=deleted: \"DL2\", \"Event2\", "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(delNum)).toString());
        
        //delete invalid task
        delNum = new ArrayList<Integer>();
        delNum.add(0);
        
        assertEquals("Display [message=You have specified invalid numbers: 0, "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(delNum)).toString());
        
        //delete multiple tasks with valid and invalid task numbers
        delNum = new ArrayList<Integer>();
        delNum.add(0);
        delNum.add(-1);
        delNum.add(3);
        
        assertEquals("Display [message=You have specified invalid numbers: 0, -1, "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDelete(delNum)).toString());
        
        //user enters invalid command
        assertEquals("Display [message=You have specified an invalid command, "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandInvalid()).toString());
        
        //user reserves time slot
        tags = new ArrayList<String>();
        ArrayList<Calendar> startDates = new ArrayList<Calendar>();
        ArrayList<Calendar> endDates = new ArrayList<Calendar>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,30);
        end.set(2016,2-1,19,16,00);
        startDates.add(start);
        endDates.add(end);
        assertEquals("Display [message=Reserved: \"r1\", "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddReserved("r1", "", startDates, endDates, tags)).toString());
        
        //user reserves multiple time slots with tags and location
        tags = new ArrayList<String>();
        startDates = new ArrayList<Calendar>();
        endDates = new ArrayList<Calendar>();
        Calendar start1 = Calendar.getInstance();
        Calendar end1 = Calendar.getInstance();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,12,00);
        end.set(2016,2-1,19,15,00);
        start1.set(2016,2-1,19,11,30);
        end1.set(2016,2-1,19,16,00);
        startDates.add(start);
        endDates.add(end);
        startDates.add(start1);
        endDates.add(end1);
        tags.add("tag1");
        tags.add("tag2");
        assertEquals("Display [message=Reserved: \"r2\", "
                + "events=["
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandAddReserved("r2", "location", startDates, endDates, tags)).toString());
        
        //show tasks containing 'l'
        assertEquals("Display [message=Displaying all tasks containing l, "
                + "events=[]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("l")).toString());//show tasks containing 'l'
        
        //show tasks at specified location
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks at location, "
                + "events=[]"
                
                + ", deadlineTasks=[], "
                
                + "floatTasks=["
                + "Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "location", null, null, tags)).toString());
        
        //show a time range
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,12,00);
        end.set(2016,2-1,19,15,00);
        
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 12:00 to 19/02/16 15:00, "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());
        
        //show a time range where time is equal to task start/end time
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,30);
        end.set(2016,2-1,19,12,00);
        
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 11:30 to 19/02/16 12:00, "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=[], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());
        
        //show a time range 
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,30);
        end.set(2016,2-1,19,11,59);
        
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks from 19/02/16 11:30 to 19/02/16 11:59, "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n]"
                
                + ", deadlineTasks=[], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", start, end, tags)).toString());
        
        //show tag
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        tags.add("tag1");
        assertEquals("Display [message=Displaying all tasks tagged tag1, "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());
        
        //show tag
        tags = new ArrayList<String>();
        tags.add("tag1");
        tags.add("tag2");
        assertEquals("Display [message=Displaying all tasks tagged tag1, tag2, "
                + "events=[]"
                
                + ", deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());
        
      //show tasks containing keyword, tags and is within time range
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,30);
        end.set(2016,2-1,19,12,00);
        assertEquals("Display [message=Displaying all tasks containing l at location from 19/02/16 11:30 to 19/02/16 12:00 tagged tag1, tag2, "
                + "events=[]"
                
                + ", deadlineTasks=[], "
                
                + "floatTasks=["
                + "Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("l", "location", start, end, tags)).toString());
        
        //show all
        tags = new ArrayList<String>();
        assertEquals("Display [message=Displaying all tasks, "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Float4\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandShow("", "", null, null, tags)).toString());
        
        //update Float task description, add location, remove tags and add tags
        ArrayList<String> removedTags = new ArrayList<String>();
        removedTags.add("tag3");
        removedTags.add("tag4");
        tags = new ArrayList<String>();
        tags.add("tag10");
        assertEquals("Display [message=Edited : \"Float4\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Floatter\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(8, "Floatter", "location", null, null, tags, removedTags)).toString());
        
        //update Float task remove location, add due date
        removedTags = new ArrayList<String>();
        tags = new ArrayList<String>();
        end = Calendar.getInstance();
        end.set(2016,2-1,19,12,00);
        assertEquals("Display [message=Edited : \"Floatter\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: Floatter\r\n"
                + "Deadline: 19/02/16 12:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"


                + ", Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(8, "", "", null, end, tags, removedTags)).toString());
        
        //update Float task add start and end time
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,45);
        end.set(2016,2-1,19,13,00);
        assertEquals("Display [message=Edited : \"Float1\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: Floatter\r\n"
                + "Deadline: 19/02/16 12:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1 #tag2 #tag5 #tag10\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(7, null, null, start, end, tags, removedTags)).toString());
        
        //update Deadline task description, add location, remove tags and add tags
        removedTags = new ArrayList<String>();
        removedTags.add("tag1");
        tags = new ArrayList<String>();
        tags.add("tag11");
        
        assertEquals("Display [message=Edited : \"Floatter\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DeadlineTask\r\n"
                + "Deadline: 19/02/16 12:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(1, "DeadlineTask", "location", null, null, tags, removedTags)).toString());
        
        //update Deadline due date and remove invalid task
        removedTags = new ArrayList<String>();
        removedTags.add("tag1");
        end = Calendar.getInstance();
        end.set(2016,2-1,19,13,00);
        
        assertEquals("Display [message=Edited : \"DeadlineTask\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DeadlineTask\r\n"
                + "Deadline: 19/02/16 13:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n, "
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(1, null, null, null, end, null, removedTags)).toString());
        
        //update Deadline- remove due date
        end = Calendar.getInstance();
        end.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"DeadlineTask\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n"
                
                + ", Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                
                + "Description: DL3\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "

                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(1, null, null, null, end, null, null)).toString());
      
        //update Deadline- add start date and change end date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,11,45);
        end.set(2016,2-1,19,14,00);
        
        assertEquals("Display [message=Edited : \"DL3\", "
                + "events=["
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 11:30\r\n"
                + "End Date: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(1, null, null, start, end, null, null)).toString());
      
        //update event start and end dates
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.set(2016,2-1,19,13,00);
        end.set(2016,2-1,19,18,00);
        
        assertEquals("Display [message=Edited : \"Event3\", "
                + "events=["
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: Event3\r\n"
                + "Start Date: 19/02/16 13:00\r\n"
                + "End Date: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n]"
                
                + ", deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(3, null, null, start, end, null, null)).toString());
      
        //update event - remove start date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"Event3\", "
                + "events=["
                + "Description: Float1\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 13:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "

                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(6, null, null, start, null, null, null)).toString());
      
        //update event - remove start and end date
        tags = new ArrayList<String>();
        start = Calendar.getInstance();
        end = Calendar.getInstance();
        start.setTimeInMillis(0);
        end.setTimeInMillis(0);
        assertEquals("Display [message=Edited : \"Float1\", "
                + "events=["
                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "
                
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"
                
                + ", Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandUpdate(4, null, null, start, end, null, null)).toString());
      
        //mark a task as done
        
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        assertEquals("Display [message=Completed: \"DL4\", "
                + "events=["
                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "deadlineTasks=["
                
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"
                
                + ", Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDone(delNum)).toString());
      
        //mark multiple tasks as done
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        delNum.add(2);
        assertEquals("Display [message=Completed: \"Event3\", \"DL1\", "
                + "events=["
                + "Description: DL3\r\n"
                + "Start Date: 19/02/16 11:45\r\n"
                + "End Date: 19/02/16 14:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: Event1\r\n"
                + "Start Date: 19/02/16 12:00\r\n"
                + "End Date: 19/02/16 15:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "deadlineTasks=[], "
                
                + "floatTasks=["
                + "Description: Float3\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n"

                + ", Description: Float5\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2 #tag3 #tag4 #tag5\r\n\r\n"
                
                + ", Description: DeadlineTask\r\n"
                + "Location: location\r\n"
                + "Tags: #tag2 #tag5 #tag10 #tag11\r\n\r\n"
                
                + ", Description: Float1\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                
                + ", reservedTasks=["
                + "Description: r1\r\n"
                + "Start Dates: 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 16:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: r2\r\n"
                + "Start Dates: 19/02/16 12:00, 19/02/16 11:30\r\n"
                + "End Dates: 19/02/16 15:00, 19/02/16 16:00\r\n"
                + "Location: location\r\n"
                + "Tags: #tag1 #tag2\r\n\r\n], "
                
                + "completedTasks=[]]", 
                Logic.executeCommand(new CommandDone(delNum)).toString());
      
        //show done
        types = new ArrayList<String>();
        types.add("done");
        assertEquals("Display [message=Displaying done tasks, "
                + "events=[], "
                
                + "deadlineTasks=[], "
                
                + "floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n, "

                
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                + "]", 
                Logic.executeCommand(new CommandShow(null, null, null, null, null, types)).toString());
        
        //undone task
        delNum = new ArrayList<Integer>();
        delNum.add(1);
        assertEquals("Display [message=Undone task: \"DL4\", "
                + "events=[], "
                
                + "deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n"
                + "],"
                
                + " floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n]"
                + "]", 
                Logic.executeCommand(new CommandUndone(delNum)).toString());
        
      //undone multiple task
        delNum = new ArrayList<Integer>();
        delNum.add(3);
        delNum.add(2);
        assertEquals("Display [message=Undone task: \"Event3\", \"DL1\", "
                + "events=[], "
                
                + "deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n"
                + ", "

                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "]]", 
                Logic.executeCommand(new CommandUndone(delNum)).toString());
        
      //done all
        assertEquals("Display [message=All shown tasks completed, "
                + "events=[], "
                
                + "deadlineTasks=[], "
                
                + "floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "]]", 
                Logic.executeCommand(new CommandDone(null)).toString());
        
      //show done
       types = new ArrayList<String>();
       types.add("done");
       Logic.executeCommand(new CommandShow(null, null, null, null, null,types));
      //undone all
        assertEquals("Display [message=All tasks undone, "
                + "events=[], "
                
                + "deadlineTasks=["
                + "Description: DL4\r\n"
                + "Deadline: 19/02/16 15:00\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n"
                + ", "

                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n], "
                
                + "floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "]]", 
                Logic.executeCommand(new CommandUndone(null)).toString());
        
      //postpone task
        start = Calendar.getInstance();
        start.set(Calendar.HOUR_OF_DAY, 2);
        start.set(Calendar.DATE, 2);
        start.set(Calendar.MINUTE, 2);
        start.set(Calendar.MONTH, 2);
        ArrayList<String> para = new ArrayList<String>();
        para.add("hour");
        para.add("day");
        para.add("minute");
        para.add("month");
        assertEquals("Display [message=Postponed: DL4, "
                + "events=[], "
                
                + "deadlineTasks=["
                + "Description: Event3\r\n"
                + "Deadline: 19/02/16 18:00\r\n"
                + "Location: \r\n"
                + "Tags: #tag1\r\n\r\n, "
                
                + "Description: DL1\r\n"
                + "Deadline: 19/02/16 19:00\r\n"
                + "Location: \r\n"
                + "Tags:\r\n\r\n, "
                
                + "Description: DL4\r\n"
                + "Deadline: 21/04/16 17:02\r\n"
                + "Location: JEM\r\n"
                + "Tags: #tag1 #tag2 #tag3\r\n\r\n"
                + "], "
                
                + "floatTasks=[]"
                
                + ", reservedTasks=[], "
                
                + "completedTasks=["
                + "]]", 
                Logic.executeCommand(new CommandPostpone(1, start, para)).toString());
        
    }

}
```
