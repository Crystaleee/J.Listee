# A0149063E
###### CS2103\src\bean\Display.java
``` java
	@Override
	public String toString() {
		return "Display [message=" + message + ", events=" + visibleEvents + ", deadlineTasks=" + visibleDeadlineTasks
				+ ", floatTasks=" + visibleFloatTasks + ", reservedTasks=" + visibleReservedTasks + ", completedTasks="
				+ visibleCompletedTasks + "]";
	}
}
```
###### CS2103\src\bean\Task.java
``` java
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.getDescription() + "\r\n");
		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append("Location: " + location + "\r\n");

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += " #" + tag;
		}

		sb.append("Tags:" + tagsString + "\r\n");
		sb.append("\r\n");
		return sb.toString();
	}
}
```
###### CS2103\src\bean\TaskDeadline.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.getDescription() + "\r\n");

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");
		String dateString = sdf.format(this.endDate.getTime());
		sb.append("Deadline: " + dateString + "\r\n");

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append("Location: " + location + "\r\n");

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += " #" + tag;
		}

		sb.append("Tags:" + tagsString + "\r\n");
		sb.append("\r\n");
		return sb.toString();
	}

}
```
###### CS2103\src\bean\TaskEvent.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.getDescription() + "\r\n");

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");
		String startDate = sdf.format(this.startDate.getTime());
		sb.append("Start Date: " + startDate + "\r\n");

		String endDate = sdf.format(this.getEndDate().getTime());
		sb.append("End Date: " + endDate + "\r\n");

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append("Location: " + location + "\r\n");

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += " #" + tag;
		}

		sb.append("Tags:" + tagsString + "\r\n");
		sb.append("\r\n");
		return sb.toString();
	}

}
```
###### CS2103\src\bean\TaskFloat.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.getDescription() + "\r\n");
		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append("Location: " + location + "\r\n");

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += " #" + tag;
		}

		sb.append("Tags:" + tagsString + "\r\n");
		sb.append("\r\n");
		return sb.toString();
	}

}
```
###### CS2103\src\bean\TaskReserved.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("Description: " + this.getDescription() + "\r\n");

		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");

		String startDates = "";
		for (int i = 0; i < this.startDates.size(); i++) {
			if (i == this.startDates.size() - 1) {
				startDates += sdf.format(this.startDates.get(i).getTime());
			} else {
				startDates += sdf.format(this.startDates.get(i).getTime()) + ", ";
			}
		}
		sb.append("Start Dates: " + startDates + "\r\n");

		String endDates = "";
		for (int i = 0; i < this.endDates.size(); i++) {
			if (i == this.endDates.size() - 1) {
				endDates += sdf.format(this.endDates.get(i).getTime());
			} else {
				endDates += sdf.format(this.endDates.get(i).getTime()) + ", ";
			}
		}
		sb.append("End Dates: " + endDates + "\r\n");

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append("Location: " + location + "\r\n");

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += " #" + tag;
		}

		sb.append("Tags:" + tagsString + "\r\n");
		sb.append("\r\n");
		return sb.toString();
	}

}
```
###### CS2103\src\parser\InputSuggestion.java
``` java
package parser;

import java.util.ArrayList;

import bean.Display;
import logic.Logic;

public class InputSuggestion {

	private static final String SUGGESTION_ADD = "add <description> [\"at/from/due/etc\"] [start time] [\"to\" end time] [@location] [#tag]";

	private static final String SUGGESTION_DEL = "del <task number(s)>";
	private static final String SUGGESTION_DELETE = "delete <task number(s)>";

	private static final String SUGGESTION_UPDATE = "update <task number> [description] [(-)/time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_UPDATE_FLOAT = "update <task number> [new description] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_UPDATE_DEADLINE = "update <task number> [new description] [(-)/end [time]] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_UPDATE_EVENT = "update <task number> [description] [(-)/time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_UPDATE_RESERVED = "<task #> [reserved block #] [description] [/time-group time(s)] [(-)@location] [(-)#tag]";

	private static final String SUGGESTION_EDIT = "edit <task number> [description] [(-)/time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT_FLOAT = "edit <task number> [new description] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT_DEADLINE = "edit <task number> [new description] [(-)/end [time]] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT_EVENT = "edit <task number> [description] [(-)/time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT_RESERVED = "<task #> [reserved block #] [description] [/time-group time(s)] [(-)@location] [(-)#tag]";

	private static final String SUGGESTION_RES = "res <description> <\"from\" start date(s) \"to\" end date(s)> [@location] [#tag]";
	private static final String SUGGESTION_RESERVE = "reserve <description> <\"from\" start date(s) \"to\" end date(s)> [@location] [#tag]";

	private static final String SUGGESTION_CFM = "cfm <task number> <reserved block number>";
	private static final String SUGGESTION_CONFIRM = "confirm <task number> <reserved block number>";

	private static final String SUGGESTION_DONE = "done  <task number(s)>";
	private static final String SUGGESTION_UNDONE = "undone  <task number(s)>";

	private static final String SUGGESTION_SEARCH = "search [/task-group] [keyword] [@location] [#tag]";
	private static final String SUGGESTION_SHOW = "show [/task-group] [keyword] [@location] [#tag]";

	private static final String SUGGESTION_POSTPONE = "postpone <task number> <time to postpone by>";
	private static final String SUGGESTION_PP = "pp <task number> <time to postpone by>";

	private static final String SUGGESTION_UNDO = "undo";
	private static final String SUGGESTION_REDO = "redo";

	private static final String SUGGESTION_FILEPATH = "change filepath";

	private static final String SUGGESTION_HELP = "help";
	private static final String SUGGESTION_EXIT = "exit";

	private static final String SUGGESTION_INVALID_COMMAND = "Invalid command!";
	private static final String SUGGESTION_INVALID_TASK = "Invalid task number!";

	private static final String SUGGESTION_EDIT_EXIT = "edit <task number> // exit";
	private static final String SUGGESTION_CONFIRM_FILEPATH = "cfm/confirm <task number(s)> <reserved block number(s)> // change filepath";
	private static final String SUGGESTION_DELETE_DEL = "del/delete <task number(s)>";
	private static final String SUGGESTION_DELETE_DONE = "del/delete <task number(s)> // done <task number(s)>";
	private static final String SUGGESTION_POSTPONE_PP = "pp/postpone <task number(s)> <time to postpone by>";
	private static final String SUGGESTION_SHOW_SEARCH = "show/search [/task-group] [keyword] [@location] [#tag]";
	private static final String SUGGESTION_UNDO_UNDONE = "undo // undone <task number(s)>";
	private static final String SUGGESTION_UNDO_UNDONE_UPDATE = "update <task number> // undo // undone <task number(s)>";
	private static final String SUGGESTION_REDO_RESERVE = "redo // reserve <description> <start dates to end dates>";

	private static final String COMMAND_ADD = "add ";

	private static final String COMMAND_DELETE = "delete ";
	private static final String COMMAND_DEL = "del ";

	private static final String COMMAND_UPDATE = "update ";
	private static final String COMMAND_EDIT = "edit ";

	private static final String COMMAND_RESERVE = "reserve ";
	private static final String COMMAND_RES = "res ";

	private static final String COMMAND_CONFIRM = "confirm ";
	private static final String COMMAND_CFM = "cfm ";

	private static final String COMMAND_DONE = "done ";
	private static final String COMMAND_UNDONE = "undone ";

	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_SHOW = "show ";

	private static final String COMMAND_POSTPONE = "postpone ";
	private static final String COMMAND_PP = "pp ";

	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";

	private static final String COMMAND_FILEPATH = "change filepath";

	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_EXIT = "exit";

	private static InputSuggestion inputSuggester;
	private static Display display = Logic.getDisplay();

	private static boolean isFloatTask;
	private static boolean isDeadlineTask;
	private static boolean isEvent;
	private static boolean isReservationTask;
	private static boolean isInvalidTask;

	private boolean hasInvalidTaskNumber(int taskNumber) {
		int numberOfTasks = display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
				+ display.getVisibleFloatTasks().size() + display.getVisibleReservedTasks().size();
		return ((taskNumber > numberOfTasks) || (taskNumber < 1));
	}

	private void determineTaskType(String userInput) {
		String[] splitInput = userInput.split("\\s+");
		if (splitInput.length >= 2) {
			Integer taskNumber = Integer.parseInt(splitInput[1]);
			isFloatTask = false;
			isDeadlineTask = false;
			isEvent = false;
			isReservationTask = false;
			isInvalidTask = false;

			if (!hasInvalidTaskNumber(taskNumber)) {
				if (taskNumber <= display.getVisibleDeadlineTasks().size()) {
					isDeadlineTask = true;
				} else {
					taskNumber -= display.getVisibleDeadlineTasks().size();
					if (taskNumber <= display.getVisibleEvents().size()) {
						isEvent = true;
					} else {
						taskNumber -= display.getVisibleEvents().size();
						if (taskNumber <= display.getVisibleFloatTasks().size()) {
							isFloatTask = true;
						} else {
							taskNumber -= display.getVisibleFloatTasks().size();
							isReservationTask = true;
						}
					}
				}
			} else {
				isInvalidTask = true;
			}
		}
	}

	public static InputSuggestion getInstance() {
		if (inputSuggester == null) {
			return new InputSuggestion();
		}
		return inputSuggester;
	}

	public String getSuggestedInput(String currentInput) {
		currentInput = currentInput.toLowerCase();
		return getSuggestionBeforeTypingCommand(currentInput);
	}

	private String getSuggestionBeforeTypingCommand(String currentInput) {
		if (currentInput.isEmpty()) {
			return null;
		} else if ("c".startsWith(currentInput)) {
			return SUGGESTION_CONFIRM_FILEPATH;
		} else if ("d".startsWith(currentInput)) {
			return SUGGESTION_DELETE_DONE;
		} else if ("del".startsWith(currentInput)) {
			return SUGGESTION_DELETE_DEL;
		} else if ("e".startsWith(currentInput)) {
			return SUGGESTION_EDIT_EXIT;
		} else if ("p".startsWith(currentInput)) {
			return SUGGESTION_POSTPONE_PP;
		} else if ("re".startsWith(currentInput)) {
			return SUGGESTION_REDO_RESERVE;
		} else if ("s".startsWith(currentInput)) {
			return SUGGESTION_SHOW_SEARCH;
		} else if ("u".startsWith(currentInput)) {
			return SUGGESTION_UNDO_UNDONE_UPDATE;
		} else if ("undo".startsWith(currentInput)) {
			return SUGGESTION_UNDO_UNDONE;
		} else {
			return getSuggestionWhileTypingCommand(currentInput);
		}
	}

	private String getSuggestionWhileTypingCommand(String currentInput) {
		ArrayList<String> suggestions = consolidateSuggestions();
		for (String suggestion : suggestions) {
			if (suggestion.startsWith(currentInput)) {
				return suggestion;
			}
		}
		return getSuggestionAfterTypingCommand(currentInput);
	}

	private String getSuggestionAfterTypingCommand(String currentInput) {
		if (currentInput.startsWith(COMMAND_ADD)) {
			return SUGGESTION_ADD;
		} else if (currentInput.startsWith(COMMAND_DEL)) {
			return SUGGESTION_DEL;
		} else if (currentInput.startsWith(COMMAND_DELETE)) {
			return SUGGESTION_DELETE;
		} else if (currentInput.startsWith(COMMAND_UPDATE)) {
			determineTaskType(currentInput);
			if (isFloatTask) {
				return SUGGESTION_UPDATE_FLOAT;
			} else if (isDeadlineTask) {
				return SUGGESTION_UPDATE_DEADLINE;
			} else if (isEvent) {
				return SUGGESTION_UPDATE_EVENT;
			} else if (isReservationTask) {
				return SUGGESTION_UPDATE_RESERVED;
			} else if (isInvalidTask) {
				return SUGGESTION_INVALID_TASK;
			} else {
				return SUGGESTION_UPDATE;
			}
		} else if (currentInput.startsWith(COMMAND_EDIT)) {
			determineTaskType(currentInput);
			if (isFloatTask) {
				return SUGGESTION_EDIT_FLOAT;
			} else if (isDeadlineTask) {
				return SUGGESTION_EDIT_DEADLINE;
			} else if (isEvent) {
				return SUGGESTION_EDIT_EVENT;
			} else if (isReservationTask) {
				return SUGGESTION_EDIT_RESERVED;
			} else if (isInvalidTask) {
				return SUGGESTION_INVALID_TASK;
			} else {
				return SUGGESTION_UPDATE;
			}
		} else if (currentInput.startsWith(COMMAND_RESERVE)) {
			return SUGGESTION_RESERVE;
		} else if (currentInput.startsWith(COMMAND_RES)) {
			return SUGGESTION_RES;
		} else if (currentInput.startsWith(COMMAND_CONFIRM)) {
			determineTaskType(currentInput);
			if (!isReservationTask) {
				return SUGGESTION_INVALID_TASK;
			} else {
				return SUGGESTION_CONFIRM;
			}
		} else if (currentInput.startsWith(COMMAND_CFM)) {
			return SUGGESTION_CFM;
		} else if (currentInput.startsWith(COMMAND_DONE)) {
			return SUGGESTION_DONE;
		} else if (currentInput.startsWith(COMMAND_UNDONE)) {
			return SUGGESTION_UNDONE;
		} else if (currentInput.startsWith(COMMAND_SHOW)) {
			return SUGGESTION_SHOW;
		} else if (currentInput.startsWith(COMMAND_SEARCH)) {
			return SUGGESTION_SEARCH;
		} else if (currentInput.startsWith(COMMAND_POSTPONE)) {
			return SUGGESTION_POSTPONE;
		} else if (currentInput.startsWith(COMMAND_PP)) {
			return SUGGESTION_PP;
		} else if (currentInput.equals(COMMAND_UNDO)) {
			return SUGGESTION_UNDO;
		} else if (currentInput.equals(COMMAND_REDO)) {
			return SUGGESTION_REDO;
		} else if (currentInput.equals(COMMAND_FILEPATH)) {
			return SUGGESTION_FILEPATH;
		} else if (currentInput.equals(COMMAND_HELP)) {
			return SUGGESTION_HELP;
		} else if (currentInput.equals(COMMAND_EXIT)) {
			return SUGGESTION_EXIT;
		} else {
			return SUGGESTION_INVALID_COMMAND;
		}
	}

	private ArrayList<String> consolidateSuggestions() {
		ArrayList<String> suggestions = new ArrayList<String>();

		suggestions.add(SUGGESTION_ADD);
		suggestions.add(SUGGESTION_RESERVE);
		suggestions.add(SUGGESTION_DEL);
		suggestions.add(SUGGESTION_DELETE);
		suggestions.add(SUGGESTION_UPDATE);
		suggestions.add(SUGGESTION_EDIT);
		suggestions.add(SUGGESTION_SHOW);
		suggestions.add(SUGGESTION_SEARCH);
		suggestions.add(SUGGESTION_CONFIRM);
		suggestions.add(SUGGESTION_CFM);
		suggestions.add(SUGGESTION_DONE);
		suggestions.add(SUGGESTION_UNDONE);
		suggestions.add(SUGGESTION_UNDO);
		suggestions.add(SUGGESTION_REDO);
		suggestions.add(SUGGESTION_FILEPATH);
		suggestions.add(SUGGESTION_POSTPONE);
		suggestions.add(SUGGESTION_PP);
		suggestions.add(SUGGESTION_HELP);
		suggestions.add(SUGGESTION_EXIT);

		return suggestions;
	}

}
```
###### CS2103\src\storage\Storage.java
``` java
package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import bean.Display;
import bean.Task;
import bean.TaskDeadline;
import bean.TaskEvent;
import bean.TaskFloat;
import bean.TaskReserved;

public class Storage {

	public static String filePath;
	private static Storage storageInstance;

	private static final String HEADER_FLOATING = "     TASKS";
	private static final String HEADER_DEADLINE = "   DEADLINES";
	private static final String HEADER_EVENT = "    EVENTS";
	private static final String HEADER_RESERVED = "   RESERVED";
	private static final String HEADER_COMPLETED = "   COMPLETED";
	private static final String HEADER_DIVIDER = "===============";

	private static final String ATTRIBUTE_DESCRIPTION = "Description:";
	private static final String ATTRIBUTE_LOCATION = "Location:";
	private static final String ATTRIBUTE_TAGS = "Tags:";
	private static final String ATTRIBUTE_DEADLINE = "Deadline:";
	private static final String ATTRIBUTE_START_DATE = "Start Date:";
	private static final String ATTRIBUTE_END_DATE = "End Date:";
	private static final String ATTRIBUTE_START_DATES = "Start Dates:";
	private static final String ATTRIBUTE_END_DATES = "End Dates:";

	private static final String MESSAGE_EMPTY = "";

	private SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");
//	private Logger logger = Logger.getLogger(Storage.class.getName());

	public static Storage getInstance() {
		if (storageInstance == null) {
			return new Storage();
		}
		return storageInstance;
	}

	// private void initializeFilePath() throws IOException {
	// filePath = LogStorage.readLogFile();
	// }

	private void setFilePath(String filepath) {
		filePath = filepath;
	}

	public void createFile(String filepath) throws IOException {
		File file = new File(filepath);
		if (!file.exists()) {
			file.createNewFile();
		}
		setFilePath(filepath);
	}

	public Display getDisplay(String filepath) throws IOException {
		//FileHandler handler = createLogHandler();
		//logger.log(Level.INFO, "Reading all tasks from file.\r\n");

		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filepath)));

		br.readLine();
		ArrayList<TaskFloat> floatTasks = readTasksFloating(br);
		ArrayList<TaskDeadline> deadlineTasks = readTasksDeadline(br);
		ArrayList<TaskEvent> events = readTasksEvents(br);
		ArrayList<TaskReserved> reservedTasks = readTasksReserved(br);
		ArrayList<Task> completedTasks = readTasksCompleted(br);

		br.close();
		//closeReaderClasses(handler, br);
		setFilePath(filepath);

		Display display = new Display(MESSAGE_EMPTY, events, deadlineTasks, floatTasks, reservedTasks, completedTasks);
		return display;
	}

	private ArrayList<TaskFloat> readTasksFloating(BufferedReader br) throws IOException {
		ArrayList<TaskFloat> floatTasks = new ArrayList<TaskFloat>();
		String line = null;
		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				String location = br.readLine();
				String tags = br.readLine();

				TaskFloat floatTask = processFloatingTask(line, location, tags);
				floatTasks.add(floatTask);
			//	logger.log(Level.INFO, "Successfully read floating task: " + floatTask.getDescription() + "\r\n");
			}
		}
		return floatTasks;
	}

	private ArrayList<TaskDeadline> readTasksDeadline(BufferedReader br) throws IOException {
		ArrayList<TaskDeadline> deadlineTasks = new ArrayList<TaskDeadline>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				String deadline = br.readLine();
				String location = br.readLine();
				String tags = br.readLine();

				TaskDeadline deadlineTask = processDeadlineTask(line, deadline, location, tags);

				if (deadlineTask != null) {
					deadlineTasks.add(deadlineTask);
			//		logger.log(Level.INFO,
			//				"Successfully read deadline task: " + deadlineTask.getDescription() + "\r\n");
				}
			}
		}
		return deadlineTasks;
	}

	private ArrayList<TaskEvent> readTasksEvents(BufferedReader br) throws IOException {
		ArrayList<TaskEvent> events = new ArrayList<TaskEvent>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				String startDate = br.readLine();
				String endDate = br.readLine();
				String location = br.readLine();
				String tags = br.readLine();

				TaskEvent eventTask = processEventTask(line, startDate, endDate, location, tags);

				if (eventTask != null) {
					events.add(eventTask);
			//		logger.log(Level.INFO, "Successfully read event task: " + eventTask.getDescription() + "\r\n");
				}
			}
		}
		return events;
	}

	private ArrayList<TaskReserved> readTasksReserved(BufferedReader br) throws IOException {
		ArrayList<TaskReserved> reservedTasks = new ArrayList<TaskReserved>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				String startDates = br.readLine();
				String endDates = br.readLine();
				String location = br.readLine();
				String tags = br.readLine();

				TaskReserved reservedTask = processReservedTask(line, startDates, endDates, location, tags);

				if (reservedTask != null) {
					reservedTasks.add(reservedTask);
			//		logger.log(Level.INFO,
			//				"Successfully read reserved task: " + reservedTask.getDescription() + "\r\n");
				}
			}
		}
		return reservedTasks;
	}

	private ArrayList<Task> readTasksCompleted(BufferedReader br) throws IOException {
		ArrayList<Task> completedTasks = new ArrayList<Task>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				Task task = null;
				String description = line;

				line = br.readLine();
				if (line.startsWith(ATTRIBUTE_LOCATION)) {
					String tags = br.readLine();
					task = processFloatingTask(description, line, tags);
				} else if (line.startsWith(ATTRIBUTE_DEADLINE)) {
					String location = br.readLine();
					String tags = br.readLine();
					task = processDeadlineTask(description, line, location, tags);
				} else if (line.startsWith(ATTRIBUTE_START_DATE)) {
					String endDate = br.readLine();
					String location = br.readLine();
					String tags = br.readLine();
					task = processEventTask(description, line, endDate, location, tags);
				} else if (line.startsWith(ATTRIBUTE_START_DATES)) {
					String endDates = br.readLine();
					String location = br.readLine();
					String tags = br.readLine();
					task = processReservedTask(description, line, endDates, location, tags);
				} else {
			//		logger.log(Level.WARNING, "Could not read completed task: " + description + "\r\n");
				}

				if (task != null) {
					completedTasks.add(task);
				}
			}
		}
		return completedTasks;
	}

	private TaskFloat processFloatingTask(String description, String location, String tagsString) throws IOException {
		description = processDescription(description);
		location = processLocation(location);
		ArrayList<String> tags = processTags(tagsString);

		TaskFloat floatingTask = new TaskFloat(description, location, tags);
		return floatingTask;
	}

	private TaskDeadline processDeadlineTask(String description, String deadlineString, String location,
			String tagsString) throws IOException {
		TaskDeadline deadlineTask = null;
		try {
			description = processDescription(description);
			Calendar deadline = processDate(deadlineString, ATTRIBUTE_DEADLINE);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			deadlineTask = new TaskDeadline(description, location, deadline, tags);

		} catch (ParseException e) {
		//	logger.log(Level.WARNING, "Deadline task has invalid deadline and can't be read.\r\n");
		}
		return deadlineTask;
	}

	private TaskEvent processEventTask(String description, String startDateString, String endDateString,
			String location, String tagsString) throws IOException {
		TaskEvent eventTask = null;
		try {
			description = processDescription(description);
			Calendar startDate = processDate(startDateString, ATTRIBUTE_START_DATE);
			Calendar endDate = processDate(endDateString, ATTRIBUTE_END_DATE);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			eventTask = new TaskEvent(description, location, startDate, endDate, tags);

		} catch (ParseException e) {
		//	logger.log(Level.WARNING, "Event task has invalid dates and can't be read.\r\n");
		}
		return eventTask;
	}

	private TaskReserved processReservedTask(String description, String startDatesString, String endDatesString,
			String location, String tagsString) throws IOException {
		TaskReserved reservedTask = null;
		try {
			description = processDescription(description);
			ArrayList<Calendar> startDates = processDates(startDatesString, ATTRIBUTE_START_DATES);
			ArrayList<Calendar> endDates = processDates(endDatesString, ATTRIBUTE_END_DATES);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			reservedTask = new TaskReserved(description, location, startDates, endDates, tags);

		} catch (ParseException e) {
		//	logger.log(Level.WARNING, "Reserved task has invalid dates and can't be read.\r\n");
		}
		return reservedTask;
	}

	private String processDescription(String description) {
		if (description.startsWith(ATTRIBUTE_DESCRIPTION)) {
			description = description.replaceFirst(ATTRIBUTE_DESCRIPTION, "").trim();
			if (description.isEmpty()) {
				description = "undefined";
			}
		}
		return description;
	}

	private String processLocation(String location) throws IOException {
		if (location.startsWith(ATTRIBUTE_LOCATION)) {
			location = location.replaceFirst(ATTRIBUTE_LOCATION, "").trim();
			if (location.isEmpty()) {
				location = null;
			}
		}
		return location;
	}

	private ArrayList<String> processTags(String tagsString) throws IOException {
		ArrayList<String> tags = null;
		if (tagsString.startsWith(ATTRIBUTE_TAGS)) {
			tags = new ArrayList<String>(Arrays.asList(tagsString.trim().split("\\s*#\\s*")));
			tags.remove(0);
		}
		return tags;
	}

	private Calendar processDate(String dateString, String dateType) throws IOException, ParseException {
		Calendar date = null;
		if (dateString.startsWith(dateType)) {
			date = Calendar.getInstance();
			date.setTime(sdf.parse(dateString.replaceFirst(dateType, "").trim()));
		}
		return date;
	}

	private ArrayList<Calendar> processDates(String datesString, String dateType) throws IOException, ParseException {
		ArrayList<Calendar> dates = new ArrayList<Calendar>();

		if (datesString.startsWith(dateType)) {
			ArrayList<String> datesList = new ArrayList<String>(
					Arrays.asList(datesString.replaceFirst(dateType, "").trim().split("\\s*,\\s*")));

			for (String dateString : datesList) {
				Calendar date = Calendar.getInstance();
				date.setTime(sdf.parse(dateString));
				dates.add(date);
			}
		}
		return dates;
	}

//	private FileHandler createLogHandler() throws IOException {
//		FileHandler handler = new FileHandler("logs\\log.txt");
//		handler.setFormatter(new SimpleFormatter());
//		logger.addHandler(handler);
//		return handler;
//	}

	private void readHeader(BufferedReader br) throws IOException {
		br.readLine();
		br.readLine();
	}

	private boolean isInvalidLine(String line) {
		return line == null || line.equals(HEADER_DIVIDER);
	}

//	private void closeReaderClasses(FileHandler handler, BufferedReader br) throws IOException {
//		br.close();
//		handler.close();
//	}

	public void saveFile(Display thisDisplay) throws IOException {
		//FileHandler handler = createLogHandler();

		//logger.log(Level.INFO, "Writing all tasks to file.\r\n");
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath)));

		ArrayList<TaskFloat> floatTasks = thisDisplay.getFloatTasks();
		ArrayList<TaskDeadline> deadlineTasks = thisDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> events = thisDisplay.getEventTasks();
		ArrayList<TaskReserved> reservedTasks = thisDisplay.getReservedTasks();
		ArrayList<Task> completedTasks = thisDisplay.getCompletedTasks();

		writeFloatingTasks(bw, floatTasks);
		writeDeadlineTasks(bw, deadlineTasks);
		writeEventTasks(bw, events);
		writeReservedTasks(bw, reservedTasks);
		writeCompletedTasks(bw, completedTasks);

		bw.flush();
		bw.close();
		//closeWriterClasses(handler, bw);
	}

	private void writeHeaderToFile(BufferedWriter bw, String header) throws IOException {
		bw.write(HEADER_DIVIDER);
		bw.newLine();
		bw.write(header);
		bw.newLine();
		bw.write(HEADER_DIVIDER);
		bw.newLine();
		bw.newLine();
	}

	private void writeFloatingTasks(BufferedWriter bw, ArrayList<TaskFloat> floatTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_FLOATING);
		for (TaskFloat task : floatTasks) {
			//logger.log(Level.INFO, "Writing " + task.getDescription() + " to file.\r\n");
			bw.write(task.toString());
		}
	}

	private void writeDeadlineTasks(BufferedWriter bw, ArrayList<TaskDeadline> deadlineTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_DEADLINE);
		for (TaskDeadline task : deadlineTasks) {
			//logger.log(Level.INFO, "Writing " + task.getDescription() + " to file.\r\n");
			bw.write(task.toString());
		}
	}

	private void writeEventTasks(BufferedWriter bw, ArrayList<TaskEvent> events) throws IOException {
		writeHeaderToFile(bw, HEADER_EVENT);
		for (TaskEvent event : events) {
			//logger.log(Level.INFO, "Writing " + event.getDescription() + " to file.\r\n");
			bw.write(event.toString());
		}
	}

	private void writeReservedTasks(BufferedWriter bw, ArrayList<TaskReserved> reservedTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_RESERVED);
		for (TaskReserved task : reservedTasks) {
			//logger.log(Level.INFO, "Writing " + task.getDescription() + " to file.\r\n");
			bw.write(task.toString());
		}
	}

	private void writeCompletedTasks(BufferedWriter bw, ArrayList<Task> completedTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_COMPLETED);
		for (Task task : completedTasks) {
			//logger.log(Level.INFO, "Writing " + task.getDescription() + " to file.\r\n");
			bw.write(task.toString());
		}
	}

//	private void closeWriterClasses(FileHandler handler, BufferedWriter bw) throws IOException {
//		bw.flush();
//		bw.close();
//		handler.close();
//	}

}
```
###### CS2103\src\storage\StorageFilePath.java
``` java
package storage;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class StorageFilePath {
	
	private static String readOldFilePath() throws IOException {
		return LogStorage.readLog();
	}
	
	public static void changeFilePath(String newFilePathString) throws IOException {
		String oldFilePathString = readOldFilePath();
		
		File newFile = new File(newFilePathString);
		if(!newFile.exists()) {
			Path oldFilePath = Paths.get(oldFilePathString);
			Path newFilePath = Paths.get(newFilePathString);
			Files.move(oldFilePath, newFilePath, StandardCopyOption.ATOMIC_MOVE);
		}
		LogStorage.writeLogFile(newFilePathString);
	}
}




```
###### CS2103\src\tests\InputSuggestionTest.java
``` java
package tests;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import parser.InputSuggestion;

public class InputSuggestionTest {

	InputSuggestion inputSuggester = InputSuggestion.getInstance();

	@Test
	public void deleteAndDoneTest() {
		String actual = inputSuggester.getSuggestedInput("d");
		String expected = "delete <task number(s)> / done <task number(s)>";
		assertEquals(actual, expected);
	}

	@Test
	public void deleteTest() {
		String actual = inputSuggester.getSuggestedInput("de");
		String expected = "delete <task number(s)>";
		assertEquals(actual, expected);
	}

	@Test
	public void doneTest() {
		String actual = inputSuggester.getSuggestedInput("do");
		String expected = "done <task number(s)>";
		assertEquals(actual, expected);
	}

	@Test
	public void undoUndoneAndUpdateTest() {
		String actual = inputSuggester.getSuggestedInput("u");
		String expected = "undo / undone <task number(s)> / update <task number>";
		assertEquals(actual, expected);
	}

	@Test
	public void undoAndUndoneTest() {
		String actual1 = inputSuggester.getSuggestedInput("un");
		String actual2 = inputSuggester.getSuggestedInput("undo");
		String expected = "undo / undone <task number(s)>";
		assertEquals(actual1, actual2, expected);
	}

	@Test
	public void updateTest() {
		String actual = inputSuggester.getSuggestedInput("up");
		String expected = "update <task number> [new description] [-delete time(s)] [new time(s)] [-@delete location] [@new location] [-#delete tag] [#new tag]";
		assertEquals(actual, expected);
	}

	@Test
	public void redoAndReserveTest() {
		String actual1 = inputSuggester.getSuggestedInput("r");
		String actual2 = inputSuggester.getSuggestedInput("re");
		String expected = "redo / reserve <description> <start dates to end dates>";
		assertEquals(actual1, actual2, expected);
	}

	@Test
	public void redoTest() {
		String actual = inputSuggester.getSuggestedInput("red");
		String expected = "redo";
		assertEquals(actual, expected);
	}

	@Test
	public void reserveTest() {
		String actual = inputSuggester.getSuggestedInput("res");
		String expected = "reserve <description> <start dates to end dates> [@location] [#tag]";
		assertEquals(actual, expected);
	}

}
```
###### CS2103\src\tests\IntegrationTest.java
``` java
package tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import bean.Display;
import logic.Logic;
import storage.Storage;

public class IntegrationTest {

	private static Display display;
	private Storage storage = Storage.getInstance();
	private String filepath = "src\\tests\\systematicTest.txt";

	@Before
	public void createTestFile() {
		Logic.createFile(filepath);
		Logic.initializeProgram(filepath);
	}

	@After
	public void deleteTestFile() {
		File testFile = new File(filepath);
		testFile.delete();
	}

	/**************************
	 * Input Validation Tests *
	 **************************/

	@Test
	public void testInvalidCommand() {
		display = Logic.executeUserCommand("This is an invalid command.");
		String expected = "You have specified an invalid command";
		String actual = display.getMessage();
		assertEquals(expected, actual);
	}

	@Test
	public void testEmptyCommand() {
		display = Logic.executeUserCommand("");
		String expected = "You have specified an invalid command";
		String actual = display.getMessage();
		assertEquals(expected, actual);
	}

//	@Test
//	public void testChangeFilePath() {
//		GUIController.changeFilePath("C:\\Users\\Chloe\\Downloads\\J.Listee.txt");
//	}
	
	/***********************
	 * Adding Tasks Tests  * 
	 * @throws IOException *
	 ***********************/

	@Test
	public void testAddFloating() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		String expected = "added: \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		System.out.println(display);
		assertTrue(display.toString().contains("floatTasks=[Description: Floating Test"));
	}

	@Test
	public void testAddDeadline() throws IOException {
		display = Logic.executeUserCommand("add Deadline Test due Thursday 3pm @NUS #tag");
		String expected = "added: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=[Description: Deadline Test"));
	}

	@Test
	public void testAddDeadlineWithoutTime() throws IOException {
		display = Logic.executeUserCommand("add Deadline Test due Thursday @NUS #tag");
		String expected = "added: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=[Description: Deadline Test"));
	}

	@Test
	public void testAddEvent() throws IOException {
		display = Logic.executeUserCommand("add Event Test from Thursday 3pm to 4pm @NUS #tag");
		String expected = "added: \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=[Description: Event Test"));
	}

	@Test
	public void testAddEmpty() throws IOException {
		display = Logic.executeUserCommand("add");
		String expected = "Please enter a description";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertEquals("Display [message=Please enter a description, events=[], deadlineTasks=[], floatTasks=[], reservedTasks=[], completedTasks=[]]", display.toString());
	}

	/************************
	 * Updating Tasks Tests * 
	 * @throws IOException  *
	 ************************/

	@Test
	public void testUpdateFloatingDescription() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 New Description");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=[Description: New Description"));
	}

	@Test
	public void testUpdateFloatingLocation() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 @newPlace");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Location: newPlace"));
	}

	@Test
	public void testUpdateFloatingTags() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 -#tag #newTag");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Tags: #newTag"));
	}

	@Test
	public void testUpdateDeadlineDescription() throws IOException {
		display = Logic.executeUserCommand("add Deadline Test due tomorrow @NUS #tag");
		display = Logic.executeUserCommand("update 1 New Description");
		String expected = "Edited : \"Deadline Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=[Description: New Description"));
	}

	@Test
	public void testUpdateDeadlineTime() throws IOException {
		display = Logic.executeUserCommand("add Deadline Test due tomorrow @NUS #tag");
		display = Logic.executeUserCommand("update 1 /end Friday 4pm");
		String expected = "Edited : \"Deadline Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("16:00"));
	}

	@Test
	public void testUpdateEventStartTime() throws IOException {
		display = Logic.executeUserCommand("add Event Test from Thursday 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 /start Thursday 12pm");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("12:00"));
	}

	@Test
	public void testUpdateEventEndTime() throws IOException {
		display = Logic.executeUserCommand("add Event Test from Thursday 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 /end Thursday 7pm");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();
		
		assertEquals(expected, actual);
		assertTrue(display.toString().contains("19:00"));
	}

	@Test
	public void testUpdateEventTimes() throws IOException {
		display = Logic.executeUserCommand("add Event Test from Thursday 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 /both Wednesday 9 pm to Thursday 10am");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("21:00"));
		assertTrue(display.toString().contains("10:00"));
	}

	/************************
	 * Deleting Tasks Tests * 
	 * @throws IOException  *
	 ************************/

	@Test
	public void testDeleteFloating() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Floating Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		System.out.println(display);
		assertFalse(display.toString().contains("floatTasks=[Floating Test"));
	}

	@Test
	public void testDeleteDeadline() throws IOException {
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertFalse(display.toString().contains("deadlineTasks=[Deadline Test"));
	}

	@Test
	public void testDeleteEvent() throws IOException {
		display = Logic.executeUserCommand("add Event Test from tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		System.out.println("BLAH: " + display);
		assertFalse(display.toString().contains("events=[Event Test"));
	}

	@Test
	public void testDeleteAll() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("add Event Test tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete all");
		String expected = "All tasks deleted";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertEquals(display.toString(), "Display [message=All tasks deleted, events=[], deadlineTasks=[], floatTasks=[], reservedTasks=[], completedTasks=[]]");
	}

	@Test
	public void testDeleteMultiple() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("add Event Test from tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1,2,3");
		String expected = "deleted: \"Deadline Test\", \"Event Test\", \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertEquals(display.toString(), "Display [message=deleted: \"Deadline Test\", \"Event Test\", \"Floating Test\", events=[], deadlineTasks=[], floatTasks=[], reservedTasks=[], completedTasks=[]]");
	}

	@Test
	public void testDeleteInvalidTaskNumber() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("delete 5");
		String expected = "You have specified invalid numbers: 5";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Floating Test"));
	}

	/*************************
	 * Reserving Tasks Tests * 
	 * @throws IOException   *
	 *************************/

	@Test
	public void testReserveSingle() throws IOException {
		display = Logic.executeUserCommand("reserve Reservation Test from Thursday 3pm to 4pm @NUS #tag");
		String expected = "Reserved: \"Reservation Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Reservation Test"));
	}

	@Test
	public void testReserveDouble() throws IOException {
		display = Logic
				.executeUserCommand("reserve Reservation Test from Thursday 3pm to 4pm and Friday 4pm to 6pm @NUS #tag");
		String expected = "Reserved: \"Reservation Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Reservation Test"));
	}

	/***********************
	 * Undo and Redo Tests * 
	 * @throws IOException *
	 ***********************/

	@Test
	public void testUndo() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("undo");
		String expected = "Undid previous commands";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertFalse(display.toString().contains("Floating Test"));
	}

	@Test
	public void testRedo() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("undo");
		display = Logic.executeUserCommand("redo");
		String expected = "Redid command(s)";
		String actual = display.getMessage();


		assertEquals(expected, actual);
		assertTrue(display.toString().contains("Floating Test"));
	}

	@Test
	public void testRedoError() throws IOException {
		display = Logic.executeUserCommand("redo");
		String expected = "You have reached the latest point possible";
		String actual = display.getMessage();

		assertEquals(expected, actual);
	}

	/******************************
	 * Mark Done and Undone Tests *
	 * @throws IOException        *
	 ******************************/

	@Test
	public void testMarkDone() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		String expected = "Completed: \"Floating Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertEquals(display.toString(), storageDisplay.toString());
	}

	@Test
	public void testMarkDoneInvalidNumber() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 10");
		String expected = "You have specified invalid task numbers: 10";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertEquals(display.toString(), storageDisplay.toString());
	}

	@Test
	public void testMarkUnDone() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		display = Logic.executeUserCommand("show /done");
		display = Logic.executeUserCommand("undone 1");
		String expected = "Undone task: \"Floating Test\"";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertEquals(display.toString(), storageDisplay.toString());
	}

	@Test
	public void testMarkUnDoneInvalidNumber() throws IOException {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		display = Logic.executeUserCommand("show Test");
		display = Logic.executeUserCommand("undone 10");
		String expected = "You have specified invalid task numbers: 10";
		String actual = display.getMessage();

		Display storageDisplay = storage.getDisplay(filepath);
		storageDisplay.setMessage(expected);

		assertEquals(expected, actual);
		assertEquals(display.toString(), storageDisplay.toString());
	}

}
```
###### CS2103\src\tests\StorageTest.java
``` java

package tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import bean.Display;
import bean.Task;
import bean.TaskDeadline;
import bean.TaskEvent;
import bean.TaskFloat;
import bean.TaskReserved;
import storage.Storage;

public class StorageTest {

	Storage storage = Storage.getInstance();
	Display display;

	/* Creates a display to be used for the unit tests */
	@Before
	public void setUpDisplay() {
		ArrayList<String> tags = new ArrayList<>(Arrays.asList("tag1, tag2"));
		Calendar date = Calendar.getInstance();

		TaskFloat floatTask = new TaskFloat("Test Floating", "NUS", tags);
		TaskDeadline deadlineTask = new TaskDeadline("Test Deadline", "NUS", date, tags);
		TaskEvent eventTask = new TaskEvent("Test Event", "NUS", date, date, tags);

		ArrayList<TaskFloat> floatTasks = new ArrayList<TaskFloat>();
		ArrayList<TaskDeadline> deadlineTasks = new ArrayList<TaskDeadline>();
		ArrayList<TaskEvent> eventTasks = new ArrayList<TaskEvent>();
		ArrayList<TaskReserved> reservedTasks = new ArrayList<TaskReserved>();
		ArrayList<Task> completedTasks = new ArrayList<Task>();

		floatTasks.add(floatTask);
		floatTasks.add(floatTask);

		deadlineTasks.add(deadlineTask);
		deadlineTasks.add(deadlineTask);

		eventTasks.add(eventTask);
		eventTasks.add(eventTask);

		display = new Display("", eventTasks, deadlineTasks, floatTasks, reservedTasks, completedTasks);
	}

	@Before
	public void prepareTextFileForTests() throws IOException {
		storage.createFile("src\\storage\\tests\\test.txt");
	}

	/* This is a case for the successful createFile() partition */
	@Test
	public void testfileExists() {
		File file = new File("src\\storage\\tests\\test.txt");
		assertTrue(file.exists());
	}

	/*
	 * This is a case for the createFile() partition proving that it creates a
	 * file in the correct location
	 */
	@Test
	public void testfileLocation() {
		File file = new File("src\\storage\\test.txt");
		assertFalse(file.exists());
	}

	/* This is a case for the normal reading from file partition */
	@Test
	public void testSaveAndRead() throws IOException {
		storage.saveFile(display);
		assertEquals(display.toString(), storage.getDisplay(Storage.filePath).toString());
	}

	/*
	 * This is a case for the reading from a file with empty descriptions
	 * partition
	 */
	@Test
	public void testReadEmptyDescription() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay("src\\storage\\tests\\emptyDescriptionTest.txt");

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		assertEquals("undefined", emptyFloat.get(0).getDescription());
		assertEquals("undefined", emptyDeadline.get(0).getDescription());
		assertEquals("undefined", emptyEvent.get(0).getDescription());
	}

	/*
	 * This is a case for the reading from a file with empty locations partition
	 */
	@Test
	public void testReadEmptyLocation() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay("src\\storage\\tests\\emptyLocationTest.txt");

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		assertEquals(null, emptyFloat.get(0).getLocation());
		assertEquals(null, emptyDeadline.get(0).getLocation());
		assertEquals(null, emptyEvent.get(0).getLocation());
	}

	/* This is a case for the reading from a file with empty tags partition */
	@Test
	public void testReadEmptyTags() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay("src\\storage\\tests\\emptyTagsTest.txt");

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		ArrayList<Task> emptyTagList = new ArrayList<Task>();

		assertEquals(emptyTagList, emptyFloat.get(0).getTags());
		assertEquals(emptyTagList, emptyDeadline.get(0).getTags());
		assertEquals(emptyTagList, emptyEvent.get(0).getTags());
	}

	/*
	 * This is a case for the reading from a file with empty deadlines partition
	 */
	@Test
	public void testReadEmptyDeadline() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay("src\\storage\\tests\\emptyDeadlineTest.txt");
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		assertTrue(emptyDeadline.isEmpty());
	}

	/* This is a case for the reading from a file with empty dates partition */
	@Test
	public void testReadEmptyDates() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay("src\\storage\\tests\\emptyDatesTest.txt");
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();
		assertTrue(emptyEvent.isEmpty());
	}

	@After
	public void closeDownAfterTests() {
		File file = new File("src\\storage\\tests\\test.txt");
		file.delete();
	}

}
```
