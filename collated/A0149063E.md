# A0149063E
###### CS2103\src\entity\GlobalLogger.java
``` java
package entity;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class GlobalLogger {

	private static final String LOGGER_ERROR = "Unable to set up logger.";
	private static final String LOGGER_FILE = "JListeeLog.log";

	private static Logger logger = Logger.getGlobal();
	private static FileHandler handler;

	public static void createLogHandler() {
		try {
			handler = new FileHandler(LOGGER_FILE);
			handler.setFormatter(new SimpleFormatter());
			logger.addHandler(handler);
		} catch (IOException e) {
			System.out.println(LOGGER_ERROR);
		}
	}

	public static Logger getLogger() {
		return logger;
	}

	public static void closeHandler() {
		handler.close();
	}
}
```
###### CS2103\src\entity\Task.java
``` java
	// String formats for the toString() method
	private static final String STRING_DESCRIPTION = "Description: %1$s\r\n";
	private static final String STRING_LOCATION = "Location: %1$s\r\n";
	private static final String STRING_TAG = " #%1$s";
	private static final String STRING_TAGS = "Tags:%1$s\r\n\r\n";

```
###### CS2103\src\entity\Task.java
``` java
	public String toString() {
		StringBuilder sb = new StringBuilder();

		sb.append(String.format(STRING_DESCRIPTION, this.getDescription()));
	
		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append(String.format(STRING_LOCATION, location));

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += String.format(STRING_TAG, tag);
		}

		sb.append(String.format(STRING_TAGS, tagsString));
		return sb.toString();
	}
}
```
###### CS2103\src\entity\TaskDeadline.java
``` java
	// String formats for the toString() method
	private static final String STRING_DESCRIPTION = "Description: %1$s\r\n";
	private static final String STRING_DEADLINE = "Deadline: %1$s\r\n";
	private static final String STRING_LOCATION = "Location: %1$s\r\n";
	private static final String STRING_TAG = " #%1$s";
	private static final String STRING_TAGS = "Tags:%1$s\r\n\r\n";
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");

```
###### CS2103\src\entity\TaskDeadline.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format(STRING_DESCRIPTION, this.getDescription()));

		String dateString = sdf.format(this._endDate.getTime());
		sb.append(String.format(STRING_DEADLINE, dateString));

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append(String.format(STRING_LOCATION, location));

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += String.format(STRING_TAG, tag);
		}

		sb.append(String.format(STRING_TAGS, tagsString));
		return sb.toString();
	}

}
```
###### CS2103\src\entity\TaskEvent.java
``` java
	// String formats for the toString() method
	private static final String STRING_DESCRIPTION = "Description: %1$s\r\n";
	private static final String STRING_START_DATE = "Start Date: %1$s\r\n";
	private static final String STRING_END_DATE = "End Date: %1$s\r\n";
	private static final String STRING_LOCATION = "Location: %1$s\r\n";
	private static final String STRING_TAG = " #%1$s";
	private static final String STRING_TAGS = "Tags:%1$s\r\n\r\n";
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");

```
###### CS2103\src\entity\TaskEvent.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format(STRING_DESCRIPTION, this.getDescription()));

		String startDate = sdf.format(this._startDate.getTime());
		sb.append(String.format(STRING_START_DATE, startDate));

		String endDate = sdf.format(this.getEndDate().getTime());
		sb.append(String.format(STRING_END_DATE, endDate));

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append(String.format(STRING_LOCATION, location));

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += String.format(STRING_TAG, tag);
		}

		sb.append(String.format(STRING_TAGS, tagsString));
		return sb.toString();
	}

}
```
###### CS2103\src\entity\TaskFloat.java
``` java
	// String formats for the toString() method
	private static final String STRING_DESCRIPTION = "Description: %1$s\r\n";
	private static final String STRING_LOCATION = "Location: %1$s\r\n";
	private static final String STRING_TAG = " #%1$s";
	private static final String STRING_TAGS = "Tags:%1$s\r\n\r\n";

```
###### CS2103\src\entity\TaskFloat.java
``` java
	public String toString() {
		StringBuilder sb = new StringBuilder();

		sb.append(String.format(STRING_DESCRIPTION, this.getDescription()));
		
		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append(String.format(STRING_LOCATION, location));

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += String.format(STRING_TAG, tag);
		}

		sb.append(String.format(STRING_TAGS, tagsString));
		return sb.toString();
	}

}
```
###### CS2103\src\entity\TaskReserved.java
``` java
	// String formats for the toString() method
	private static final String STRING_DESCRIPTION = "Description: %1$s\r\n";
	private static final String STRING_START_DATES = "Start Dates: %1$s\r\n";
	private static final String STRING_END_DATES = "End Dates: %1$s\r\n";
	private static final String STRING_LOCATION = "Location: %1$s\r\n";
	private static final String STRING_TAG = " #%1$s";
	private static final String STRING_TAGS = "Tags:%1$s\r\n\r\n";
	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy HH:mm");

```
###### CS2103\src\entity\TaskReserved.java
``` java
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format(STRING_DESCRIPTION, this.getDescription()));

		String startDates = "";
		for (int i = 0; i < this._startDates.size(); i++) {
			if (i == this._startDates.size() - 1) {
				startDates += sdf.format(this._startDates.get(i).getTime());
			} else {
				startDates += sdf.format(this._startDates.get(i).getTime()) + ", ";
			}
		}
		sb.append(String.format(STRING_START_DATES, startDates));

		String endDates = "";
		for (int i = 0; i < this._endDates.size(); i++) {
			if (i == this._endDates.size() - 1) {
				endDates += sdf.format(this._endDates.get(i).getTime());
			} else {
				endDates += sdf.format(this._endDates.get(i).getTime()) + ", ";
			}
		}
		sb.append(String.format(STRING_END_DATES, endDates));

		String location = this.getLocation();
		if (location == null) {
			location = "";
		}
		sb.append(String.format(STRING_LOCATION, location));

		ArrayList<String> tagsList = this.getTags();
		String tagsString = "";
		for (String tag : tagsList) {
			tagsString += String.format(STRING_TAG, tag);
		}

		sb.append(String.format(STRING_TAGS, tagsString));
		return sb.toString();
	}

}
```
###### CS2103\src\parser\InputSuggestion.java
``` java
package parser;

import java.util.ArrayList;

import entity.Display;
import logic.Logic;

public class InputSuggestion {

	/* Suggestions for each of the commands. */
	private static final String SUGGESTION_ADD = "add <description> [at/from/due/etc] [start time] [to end time] [@location] [#tag]";
	private static final String SUGGESTION_BACK = "back";
	private static final String SUGGESTION_CHANGE_FILEPATH = "change filepath";
	private static final String SUGGESTION_CFM = "cfm <task number> <timeslot number>";
	private static final String SUGGESTION_CONFIRM = "confirm <task number> <timeslot number>";
	private static final String SUGGESTION_DEL = "del <task number(s)>";
	private static final String SUGGESTION_DELETE = "delete <task number(s)>";
	private static final String SUGGESTION_DONE = "done <task number(s)>";
	private static final String SUGGESTION_UPDATE = "update <task number> [description] [(-/+)time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_UPDATE_RESERVED = "update <task number> [+del timeslot(s)] [timeslot #] [description] [+time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT = "edit <task number> [description] [(-/+)time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EDIT_RESERVED = "edit <task number> [+del timeslot(s)] [timeslot #] [description] [+time-group time(s)] [(-)@location] [(-)#tag]";
	private static final String SUGGESTION_EXIT = "exit";
	private static final String SUGGESTION_HELP = "help";
	private static final String SUGGESTION_PP = "pp <task number> <time to postpone by>";
	private static final String SUGGESTION_POSTPONE = "postpone <task number> <time to postpone by>";
	private static final String SUGGESTION_REDO = "redo";
	private static final String SUGGESTION_RES = "res <description> <from start date(s) to end date(s)> [@location] [#tag]";
	private static final String SUGGESTION_RESERVE = "reserve <description> <from start date(s) to end date(s)> [@location] [#tag]";
	private static final String SUGGESTION_SEARCH = "search [/task-group] [keyword] [at/from/due/etc time] [@location] [#tag]";
	private static final String SUGGESTION_SHOW = "show [/task-group] [keyword] [at/from/due/etc time] [@location] [#tag]";
	private static final String SUGGESTION_UNDO = "undo";
	private static final String SUGGESTION_UNDONE = "undone  <task number(s)>";
	private static final String SUGGESTION_INVALID_COMMAND = "Invalid command!";

	/* Suggestions for commands that start with the same letter or substring. */
	private static final String SUGGESTION_EDIT_EXIT = "edit <task number> // exit";
	private static final String SUGGESTION_CONFIRM_FILEPATH = "cfm/confirm <task number> <timeslot number> // change filepath";
	private static final String SUGGESTION_DELETE_DEL = "del/delete <task number(s)>";
	private static final String SUGGESTION_DELETE_DONE = "del/delete <task number(s)> // done <task number(s)>";
	private static final String SUGGESTION_POSTPONE_PP = "pp/postpone <task number> <time to postpone by>";
	private static final String SUGGESTION_SHOW_SEARCH = "show/search [/task-group] [keyword] [at/from/due/etc time] [@location] [#tag]";
	private static final String SUGGESTION_UNDO_UNDONE = "undo // undone <task number(s)>";
	private static final String SUGGESTION_UNDO_UNDONE_UPDATE = "update <task number> // undo // undone <task number(s)>";
	private static final String SUGGESTION_REDO_RESERVE = "redo // res/reserve <description> <from start date(s) to end date(s)>";
	private static final String SUGGESTION_RES_RESERVE = "res/reserve <description> <from start date(s) to end date(s)>";

	/* The prefixes that commands have when they share first couple characters. */
	private static final String PREFIX_CONFIRM_FILEPATH = "c";
	private static final String PREFIX_DELETE_DONE = "d";
	private static final String PREFIX_DELETE_DEL = "del";
	private static final String PREFIX_EDIT_EXIT = "e";
	private static final String PREFIX_POSTPONE_PP = "p";
	private static final String PREFIX_REDO_RESERVE = "re";
	private static final String PREFIX_RES_RESERVE = "res";
	private static final String PREFIX_SHOW_SEARCH = "s";
	private static final String PREFIX_UNDO_UNDONE_UPDATE = "u";
	private static final String PREFIX_UNDO_UNDONE = "undo";
	
	/* The commands that the user can type in. */
	private static final String COMMAND_ADD = "add ";
	private static final String COMMAND_BACK = "back";
	private static final String COMMAND_CHANGE_FILEPATH = "change filepath";
	private static final String COMMAND_CFM = "cfm ";
	private static final String COMMAND_CONFIRM = "confirm ";
	private static final String COMMAND_DEL = "del ";
	private static final String COMMAND_DELETE = "delete ";
	private static final String COMMAND_DONE = "done ";
	private static final String COMMAND_UPDATE = "update ";
	private static final String COMMAND_EDIT = "edit ";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_PP = "pp ";
	private static final String COMMAND_POSTPONE = "postpone ";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_RES = "res ";
	private static final String COMMAND_RESERVE = "reserve ";
	private static final String COMMAND_SEARCH = "search ";
	private static final String COMMAND_SHOW = "show ";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_UNDONE = "undone ";

	private static InputSuggestion inputSuggester_;

	/**
	 * Get an instance of InputSuggestion for other classes to use.
	 * 
	 * @return An InputSuggestion object.
	 */
	public static InputSuggestion getInstance() {
		if (inputSuggester_ == null) {
			return new InputSuggestion();
		}
		return inputSuggester_;
	}

	/**
	 * Gets a suggested input based on what the user is typing.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              An input suggestion.
	 */
	public String getSuggestedInput(String currentInput) {
		currentInput = currentInput.toLowerCase();
		return getSuggestionForCommandsWithSamePrefix(currentInput);
	}

	/**
	 * Gets a suggested input based on the first few characters the user has
	 * typed in. These suggestions are for commands that start with the same
	 * letter.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              An input suggestion.
	 */
	private String getSuggestionForCommandsWithSamePrefix(String currentInput) {
		if (currentInput.isEmpty()) {
			return null;
		} else if (PREFIX_CONFIRM_FILEPATH.startsWith(currentInput)) {
			return SUGGESTION_CONFIRM_FILEPATH;
		} else if (PREFIX_DELETE_DONE.startsWith(currentInput)) {
			return SUGGESTION_DELETE_DONE;
		} else if (PREFIX_DELETE_DEL.startsWith(currentInput)) {
			return SUGGESTION_DELETE_DEL;
		} else if (PREFIX_EDIT_EXIT.startsWith(currentInput)) {
			return SUGGESTION_EDIT_EXIT;
		} else if (PREFIX_POSTPONE_PP.startsWith(currentInput)) {
			return SUGGESTION_POSTPONE_PP;
		} else if (PREFIX_REDO_RESERVE.startsWith(currentInput)) {
			return SUGGESTION_REDO_RESERVE;
		} else if (PREFIX_RES_RESERVE.startsWith(currentInput)) {
			return SUGGESTION_RES_RESERVE;
		} else if (PREFIX_SHOW_SEARCH.startsWith(currentInput)) {
			return SUGGESTION_SHOW_SEARCH;
		} else if (PREFIX_UNDO_UNDONE_UPDATE.startsWith(currentInput)) {
			return SUGGESTION_UNDO_UNDONE_UPDATE;
		} else if (PREFIX_UNDO_UNDONE.startsWith(currentInput)) {
			return SUGGESTION_UNDO_UNDONE;
		} else {
			return getSuggestionWhileTypingCommand(currentInput);
		}
	}

	/**
	 * Gets a suggested input for a command based on what the user is typing.
	 * This command is for when the user is in the middle of writing the
	 * command.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              A suggested input.
	 */
	private String getSuggestionWhileTypingCommand(String currentInput) {
		ArrayList<String> suggestions = consolidateSuggestions();
		for (String suggestion : suggestions) {
			if (suggestion.startsWith(currentInput)) {
				return suggestion;
			}
		}
		return getSuggestionAfterTypingCommand(currentInput);
	}

	/**
	 * Gets a suggested input after the user has typed in the command and is
	 * currently typing in the parameters for the command.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              A suggested input.
	 */
	private String getSuggestionAfterTypingCommand(String currentInput) {
		if (currentInput.startsWith(COMMAND_ADD)) {
			return SUGGESTION_ADD;
		} else if (currentInput.startsWith(COMMAND_BACK)) {
			return SUGGESTION_BACK;
		} else if (currentInput.startsWith(COMMAND_DEL)) {
			return SUGGESTION_DEL;
		} else if (currentInput.startsWith(COMMAND_DELETE)) {
			return SUGGESTION_DELETE;
		} else if (currentInput.startsWith(COMMAND_UPDATE)) {
			return getUpdateSuggestion(currentInput);
		} else if (currentInput.startsWith(COMMAND_EDIT)) {
			return getEditSuggestion(currentInput);
		} else if (currentInput.startsWith(COMMAND_RESERVE)) {
			return SUGGESTION_RESERVE;
		} else if (currentInput.startsWith(COMMAND_RES)) {
			return SUGGESTION_RES;
		} else if (currentInput.startsWith(COMMAND_CONFIRM)) {
			return SUGGESTION_CONFIRM;
		} else if (currentInput.startsWith(COMMAND_CFM)) {
			return SUGGESTION_CFM;
		} else if (currentInput.startsWith(COMMAND_DONE)) {
			return SUGGESTION_DONE;
		} else if (currentInput.startsWith(COMMAND_UNDONE)) {
			return SUGGESTION_UNDONE;
		} else if (currentInput.startsWith(COMMAND_SHOW)) {
			return SUGGESTION_SHOW;
		} else if (currentInput.startsWith(COMMAND_SEARCH)) {
			return SUGGESTION_SEARCH;
		} else if (currentInput.startsWith(COMMAND_POSTPONE)) {
			return SUGGESTION_POSTPONE;
		} else if (currentInput.startsWith(COMMAND_PP)) {
			return SUGGESTION_PP;
		} else if (currentInput.equals(COMMAND_UNDO)) {
			return SUGGESTION_UNDO;
		} else if (currentInput.equals(COMMAND_REDO)) {
			return SUGGESTION_REDO;
		} else if (currentInput.equals(COMMAND_CHANGE_FILEPATH)) {
			return SUGGESTION_CHANGE_FILEPATH;
		} else if (currentInput.equals(COMMAND_HELP)) {
			return SUGGESTION_HELP;
		} else if (currentInput.equals(COMMAND_EXIT)) {
			return SUGGESTION_EXIT;
		} else {
			return SUGGESTION_INVALID_COMMAND;
		}
	}

	/**
	 * Consolidates all of the suggestions into an ArrayList, allowing
	 * getSuggestionWhileTypingCommand() to iterate over a list while looking
	 * for a suggestions.
	 * 
	 * @return  An ArrayList of input suggestions.
	 */
	private ArrayList<String> consolidateSuggestions() {
		ArrayList<String> suggestions = new ArrayList<String>();

		suggestions.add(SUGGESTION_ADD);
		suggestions.add(SUGGESTION_BACK);
		suggestions.add(SUGGESTION_CHANGE_FILEPATH);
		suggestions.add(SUGGESTION_CFM);
		suggestions.add(SUGGESTION_CONFIRM);
		suggestions.add(SUGGESTION_DEL);
		suggestions.add(SUGGESTION_DELETE);
		suggestions.add(SUGGESTION_DONE);
		suggestions.add(SUGGESTION_UPDATE);
		suggestions.add(SUGGESTION_EDIT);
		suggestions.add(SUGGESTION_EXIT);
		suggestions.add(SUGGESTION_HELP);
		suggestions.add(SUGGESTION_PP);
		suggestions.add(SUGGESTION_POSTPONE);
		suggestions.add(SUGGESTION_REDO);
		suggestions.add(SUGGESTION_RESERVE);
		suggestions.add(SUGGESTION_SEARCH);
		suggestions.add(SUGGESTION_SHOW);
		suggestions.add(SUGGESTION_UNDONE);
		suggestions.add(SUGGESTION_UNDO);

		return suggestions;
	}

	/**
	 * Gets the input suggestion for updating a task based on whether it is a
	 * Reserved Task or not.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              An input suggestion.
	 */
	private String getUpdateSuggestion(String currentInput) {
		if (isReservedTask(currentInput)) {
			return SUGGESTION_UPDATE_RESERVED;
		} else {
			return SUGGESTION_UPDATE;
		}
	}

	/**
	 * Gets the input suggestion for editing a a task based on whether it is a
	 * Reserved Task or not.
	 * 
	 * @param currentInput  What the user has currently typed in.
	 * @return              An input suggestion.
	 */
	private String getEditSuggestion(String currentInput) {
		if (isReservedTask(currentInput)) {
			return SUGGESTION_EDIT_RESERVED;
		} else {
			return SUGGESTION_EDIT;
		}
	}

	/**
	 * Determines whether a Task is a ReservedTask or not.
	 * 
	 * @param userInput  What the user has currently typed in.
	 * @return           True if the user types in a Reserved Task. Otherwise, false.
	 */
	private boolean isReservedTask(String userInput) {
		Display display = Logic.getDisplay();
		String[] splitInput = userInput.split("\\s+");

		if (splitInput.length >= 2) {
			Integer taskNumber = Integer.parseInt(splitInput[1]);

			if (!hasInvalidTaskNumber(taskNumber)) {
				if (taskNumber > display.getVisibleDeadlineTasks().size()) {
					taskNumber -= display.getVisibleDeadlineTasks().size();
					if (taskNumber > display.getVisibleEvents().size()) {
						taskNumber -= display.getVisibleEvents().size();
						if (taskNumber > display.getVisibleFloatTasks().size()) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	/**
	 * Checks to see if the user inputed an invalid task.
	 * 
	 * @param taskNumber  The task number the user has typed in.
	 * @return            True if it is an invalid task number. Otherwise, false.
	 */
	private boolean hasInvalidTaskNumber(int taskNumber) {
		Display display = Logic.getDisplay();
		int numberOfTasks = display.getVisibleDeadlineTasks().size() + display.getVisibleEvents().size()
				+ display.getVisibleFloatTasks().size() + display.getVisibleReservedTasks().size();
		return ((taskNumber > numberOfTasks) || (taskNumber < 1));
	}

}
```
###### CS2103\src\storage\Storage.java
``` java
package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

import entity.Display;
import entity.GlobalLogger;
import entity.Task;
import entity.TaskDeadline;
import entity.TaskEvent;
import entity.TaskFloat;
import entity.TaskReserved;

public class Storage {

	private static String filePath_;
	private static Storage storageInstance_;

	private static SimpleDateFormat sdf_ = new SimpleDateFormat("dd/MM/yy HH:mm");
	private static Logger logger_ = GlobalLogger.getLogger();
	
	/* Headers that divide the text file into the different task categories. */
	private static final String HEADER_FLOATING = "     TASKS";
	private static final String HEADER_DEADLINE = "   DEADLINES";
	private static final String HEADER_EVENT = "    EVENTS";
	private static final String HEADER_RESERVED = "   RESERVED";
	private static final String HEADER_COMPLETED = "   COMPLETED";
	private static final String HEADER_DIVIDER = "===============";

	/* The attributes of each task. */
	private static final String ATTRIBUTE_DESCRIPTION = "Description:";
	private static final String ATTRIBUTE_LOCATION = "Location:";
	private static final String ATTRIBUTE_TAGS = "Tags:";
	private static final String ATTRIBUTE_DEADLINE = "Deadline:";
	private static final String ATTRIBUTE_START_DATE = "Start Date:";
	private static final String ATTRIBUTE_END_DATE = "End Date:";
	private static final String ATTRIBUTE_START_DATES = "Start Dates:";
	private static final String ATTRIBUTE_END_DATES = "End Dates:";

	/* Inputs into the display for an empty attribute. */
	private static final String EMPTY_MESSAGE = "";
	private static final String EMPTY_DESCRIPTION = "undefined";

	/* Messages to be logged for successfully reading a task. */
	private static final String LOGGER_READ_FLOATING = "Successfully read floating task: %1$s";
	private static final String LOGGER_READ_DEADLINE = "Successfully read deadline task: %1$s";
	private static final String LOGGER_READ_EVENT = "Successfully read event: %1$s";
	private static final String LOGGER_READ_RESERVED = "Successfully read reserved task: %1$s";
	private static final String LOGGER_READ_COMPLETED = "Successfully read completed task: %1$s";

	/* Messages to be logged if there is an error in reading a task. */
	private static final String LOGGER_READ_ERROR_DEADLINE = "Deadline task has invalid deadline and can't be read.";
	private static final String LOGGER_READ_ERROR_EVENT = "Event task has invalid dates and can't be read.";
	private static final String LOGGER_READ_ERROR_RESERVED = "Reserved task has invalid dates and can't be read.";
	private static final String LOGGER_READ_ERROR_COMPLETED = "Could not read completed task: %1$s";

	/* Messages to be logged for successfully writing a task. */
	private static final String LOGGER_WRITE_FLOATING = "Successfully wrote floating task: %1$s";
	private static final String LOGGER_WRITE_DEADLINE = "Successfully wrote deadline task: %1$s";
	private static final String LOGGER_WRITE_EVENT = "Successfully wrote event: %1$s";
	private static final String LOGGER_WRITE_RESERVED = "Successfully wrote reserved task: %1$s";
	private static final String LOGGER_WRITE_COMPLETED = "Successfully wrote completed task: %1$s";

	/**
	 * Gets an instance of Storage for other classes to use.
	 * 
	 * @return A Storage object.
	 */
	public static Storage getInstance() {
		if (storageInstance_ == null) {
			return new Storage();
		}
		return storageInstance_;
	}

	/**
	 * Creates the text file that will be used to store the tasks of J.Listee.
	 * 
	 * @param filepath      Location of where the file will be created.
	 * @throws IOException  If I/O operations fail.
	 */
	public void createFile(String filepath) throws IOException {
		File file = new File(filepath);
		if (!file.exists()) {
			file.createNewFile();
		}
		setFilePath(filepath);
	}

	/**
	 * Changes the location of the text file to a new filepath. If a valid
	 * storage file exists in the new filepath, read storage from there.
	 * 
	 * @param newFilePathString  The new location of the storage text file.
	 * @throws IOException       If I/O operations fail.
	 */
	public void changeFilePath(String newFilePathString) throws IOException {
		String oldFilePathString = readOldFilePath();

		File newFile = new File(newFilePathString);
		if (!newFile.exists()) {
			Path oldFilePath = Paths.get(oldFilePathString);
			Path newFilePath = Paths.get(newFilePathString);
			Files.move(oldFilePath, newFilePath, StandardCopyOption.ATOMIC_MOVE);
		}
		LogStorage.writeLogFile(newFilePathString);
		setFilePath(newFilePathString);
	}

	/**
	 * Reads the location of the old storage text file.
	 * 
	 * @return              The location of the text file.
	 * @throws IOException  If I/O operations fail.
	 */
	private String readOldFilePath() throws IOException {
		return LogStorage.readLog();
	}
	
	/**
	 * Reads storage's text file to create and return a Display object.
	 * 
	 * @param filepath     The filepath of the text file.
	 * @return             A display with the user's lists of tasks.
	 * @throws IOException If I/O operations fail.
	 */
	public Display getDisplay(String filepath) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filepath)));

		ArrayList<TaskFloat> floatTasks = getFloatingTaskList(br);
		ArrayList<TaskDeadline> deadlineTasks = getDeadlineTaskList(br);
		ArrayList<TaskEvent> events = getEventTaskList(br);
		ArrayList<TaskReserved> reservedTasks = getReservedTaskList(br);
		ArrayList<Task> completedTasks = getCompletedTaskList(br);

		closeReaderClasses(br);
		setFilePath(filepath);

		Display display = new Display(EMPTY_MESSAGE, events, deadlineTasks, floatTasks, reservedTasks, completedTasks);
		return display;
	}

	/**
	 * Reads storage's text file to create and return an ArrayList of TaskFloats.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @return             The ArrayList of TaskFloats.
	 * @throws IOException If I/O operations fail.
	 */
	private ArrayList<TaskFloat> getFloatingTaskList(BufferedReader br) throws IOException {
		ArrayList<TaskFloat> floatTasks = new ArrayList<TaskFloat>();
		String line = null;

		br.readLine();
		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				assert line != null : "There is no floating task to read.";
				readFloatingTask(br, floatTasks, line);
			}
		}
		return floatTasks;
	}

	/**
	 * Reads storage's text file to create and return an ArrayList of TaskDeadlines.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @return             The ArrayList of TaskDeadlines.
	 * @throws IOException If I/O operations fail.
	 */
	private ArrayList<TaskDeadline> getDeadlineTaskList(BufferedReader br) throws IOException {
		ArrayList<TaskDeadline> deadlineTasks = new ArrayList<TaskDeadline>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				assert line != null : "There is no deadline task to read.";
				readDeadlineTask(br, deadlineTasks, line);
			}
		}
		return deadlineTasks;
	}

	/**
	 * Reads storage's text file to create and return an ArrayList of TaskEvents.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @return             The ArrayList of TaskEvents.
	 * @throws IOException If I/O operations fail.
	 */
	private ArrayList<TaskEvent> getEventTaskList(BufferedReader br) throws IOException {
		ArrayList<TaskEvent> events = new ArrayList<TaskEvent>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				assert line != null : "There is no event to read.";
				readEventTask(br, events, line);
			}
		}
		return events;
	}

	/**
	 * Reads storage's text file to create and return an ArrayList of TaskReserveds.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @return             The ArrayList of TaskReserveds.
	 * @throws IOException If I/O operations fail.
	 */
	private ArrayList<TaskReserved> getReservedTaskList(BufferedReader br) throws IOException {
		ArrayList<TaskReserved> reservedTasks = new ArrayList<TaskReserved>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				assert line != null : "There is no reserved task to read.";
				readReservedTask(br, reservedTasks, line);
			}
		}
		return reservedTasks;
	}

	/**
	 * Reads storage's text file to create and return an ArrayList of completed Tasks.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @return             The ArrayList of completed Tasks.
	 * @throws IOException If I/O operations fail.
	 */
	private ArrayList<Task> getCompletedTaskList(BufferedReader br) throws IOException {
		ArrayList<Task> completedTasks = new ArrayList<Task>();
		String line = null;

		readHeader(br);

		while ((line = br.readLine()) != null) {
			line = br.readLine();
			if (isInvalidLine(line)) {
				break;
			} else {
				assert line != null : "There is no completed task to read.";
				readCompletedTask(br, completedTasks, line);
			}
		}
		return completedTasks;
	}

	/**
	 * Reads a floating task from the text file and adds it to the ArrayList of TaskFloats.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param floatTasks   The ArrayList of TaskFloats.
	 * @param line         The line of text the BufferedReader is just read.
	 * @throws IOException If I/O operations fail.
	 */
	private void readFloatingTask(BufferedReader br, ArrayList<TaskFloat> floatTasks, String line) throws IOException {
		String location = br.readLine();
		String tags = br.readLine();

		TaskFloat floatTask = processFloatingTask(line, location, tags);
		addFloatingTaskToList(floatTasks, floatTask);
	}

	
	/**
	 * Reads a deadline task from the text file and adds it to the ArrayList of TaskDeadlines.
	 * 
	 * @param br            A BufferedReader that reads the text file.
	 * @param deadlineTasks The ArrayList of TaskDeadlines.
	 * @param line          The line of text the BufferedReader is just read.
	 * @throws IOException  If I/O operations fail.
	 */
	private void readDeadlineTask(BufferedReader br, ArrayList<TaskDeadline> deadlineTasks, String line)
			throws IOException {
		String deadline = br.readLine();
		String location = br.readLine();
		String tags = br.readLine();

		TaskDeadline deadlineTask = processDeadlineTask(line, deadline, location, tags);
		addDeadlineTaskToList(deadlineTasks, deadlineTask);
	}

	/**
	 * Reads a event from the text file and adds it to the ArrayList of TaskEvents.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param events       The ArrayList of TaskEvents.
	 * @param line         The line of text the BufferedReader is just read.
	 * @throws IOException If I/O operations fail.
	 */
	private void readEventTask(BufferedReader br, ArrayList<TaskEvent> events, String line) throws IOException {
		String startDate = br.readLine();
		String endDate = br.readLine();
		String location = br.readLine();
		String tags = br.readLine();

		TaskEvent eventTask = processEventTask(line, startDate, endDate, location, tags);
		addEventTaskToList(events, eventTask);
	}

	/**
	 * Reads a reserved task from the text file and adds it to the ArrayList of TaskReserveds.
	 * 
	 * @param br            A BufferedReader that reads the text file.
	 * @param reservedTasks The ArrayList of TaskReserveds.
	 * @param line          The line of text the BufferedReader is just read.
	 * @throws IOException  If I/O operations fail.
	 */
	private void readReservedTask(BufferedReader br, ArrayList<TaskReserved> reservedTasks, String line)
			throws IOException {
		String startDates = br.readLine();
		String endDates = br.readLine();
		String location = br.readLine();
		String tags = br.readLine();

		TaskReserved reservedTask = processReservedTask(line, startDates, endDates, location, tags);
		addReservedTaskToList(reservedTasks, reservedTask);
	}

	/**
	 * Reads a completed task from the text file and adds it to the ArrayList of Tasks.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param Tasks   The ArrayList of Tasks.
	 * @param line         The line of text the BufferedReader is just read.
	 * @throws IOException If I/O operations fail.
	 */
	private void readCompletedTask(BufferedReader br, ArrayList<Task> completedTasks, String line) throws IOException {
		Task task = null;
		String description = line;
		line = br.readLine();
		
		if (isCompletedFloatingTask(line)) {
			task = readCompletedFloatingTask(br, line, description);
		} else if (isCompletedDeadlineTask(line)) {
			task = readCompletedDeadlineTask(br, line, description);
		} else if (isCompletedEventTask(line)) {
			task = readCompletedEventTask(br, line, description);
		} else if (isCompletedReservedTask(line)) {
			task = readCompletedReservedTask(br, line, description);
		} else {
			logger_.log(Level.WARNING, String.format(LOGGER_READ_ERROR_COMPLETED, description));
		}
		
		addCompletedTaskToList(completedTasks, task);
	}

	/**
	 * Determines if the completed task is a TaskEvent.
	 * 
	 * @param line The second line of the task in the text file.
	 * @return     True if the task is a TaskFloat. False, otherwise.
	 */
	private boolean isCompletedFloatingTask(String line) {
		return line.startsWith(ATTRIBUTE_LOCATION);
	}

	/**
	 * Determines if the completed task is a TaskDeadline.
	 * 
	 * @param line The second line of the task in the text file.
	 * @return     True if the task is a TaskDeadline. False, otherwise.
	 */
	private boolean isCompletedDeadlineTask(String line) {
		return line.startsWith(ATTRIBUTE_DEADLINE);
	}

	/**
	 * Determines if the completed task is a TaskEvent.
	 * 
	 * @param line The second line of the task in the text file.
	 * @return     True if the task is a TaskEvent. False, otherwise.
	 */
	private boolean isCompletedEventTask(String line) {
		return line.startsWith(ATTRIBUTE_START_DATE);
	}

	/**
	 * Determines if the completed task is a TaskReserved.
	 * 
	 * @param line The second line of the task in the text file.
	 * @return     True if the task is a TaskReserved. False, otherwise.
	 */
	private boolean isCompletedReservedTask(String line) {
		return line.startsWith(ATTRIBUTE_START_DATES);
	}

	/**
	 * Reads and returns a completed TaskFloat from the text file.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param line         The line of text the BufferedReader is just read.
	 * @param description  The description of the completed task.
	 * @return             A completed TaskFloat.
	 * @throws IOException If I/O operations fail.
	 */
	private Task readCompletedFloatingTask(BufferedReader br, String line, String description) throws IOException {
		String tags = br.readLine();
		Task task = processFloatingTask(description, line, tags);
		return task;
	}

	/**
	 * Reads and returns a completed TaskDeadline from the text file.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param line         The line of text the BufferedReader is just read.
	 * @param description  The description of the completed task.
	 * @return             A completed TaskDeadline.
	 * @throws IOException If I/O operations fail.
	 */
	private Task readCompletedDeadlineTask(BufferedReader br, String line, String description) throws IOException {
		String location = br.readLine();
		String tags = br.readLine();
		Task task = processDeadlineTask(description, line, location, tags);
		return task;
	}

	/**
	 * Reads and returns a completed TaskEvent from the text file.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param line         The line of text the BufferedReader is just read.
	 * @param description  The description of the completed task.
	 * @return             A completed TaskEvent.
	 * @throws IOException If I/O operations fail.
	 */
	private Task readCompletedEventTask(BufferedReader br, String line, String description) throws IOException {
		String endDate = br.readLine();
		String location = br.readLine();
		String tags = br.readLine();
		Task task = processEventTask(description, line, endDate, location, tags);
		return task;
	}

	/**
	 * Reads and returns a completed TaskReserved from the text file.
	 * 
	 * @param br           A BufferedReader that reads the text file.
	 * @param line         The line of text the BufferedReader is just read.
	 * @param description  The description of the completed task.
	 * @return             A completed TaskReserved.
	 * @throws IOException If I/O operations fail.
	 */
	private Task readCompletedReservedTask(BufferedReader br, String line, String description) throws IOException {
		String endDates = br.readLine();
		String location = br.readLine();
		String tags = br.readLine();
		Task task = processReservedTask(description, line, endDates, location, tags);
		return task;
	}

	/**
	 * Processes the information read to create and return a TaskFloat.
	 * 
	 * @param description  The description of the TaskFloat.
	 * @param location     The location of the TaskFloat.
	 * @param tagsString   The tags of the TaskFloat as a String.
	 * @return             A TaskFloat.
	 * @throws IOException If I/O operations fail.
	 */
	private TaskFloat processFloatingTask(String description, String location, String tagsString) throws IOException {
		description = processDescription(description);
		location = processLocation(location);
		ArrayList<String> tags = processTags(tagsString);

		TaskFloat floatingTask = new TaskFloat(description, location, tags);
		return floatingTask;
	}

	/**
	 * Processes the information read to create and return a TaskDeadline.
	 * 
	 * @param description    The description of the TaskDeadline.
	 * @param deadlineString The deadline of the TaskDeadline as a String.
	 * @param location       The location of the TaskDeadline.
	 * @param tagsString     The tags of the TaskDeadline as a String.
	 * @return               A TaskDeadline.
	 * @throws IOException   If I/O operations fail.
	 */
	private TaskDeadline processDeadlineTask(String description, String deadlineString, String location,
			String tagsString) throws IOException {
		TaskDeadline deadlineTask = null;
		try {
			description = processDescription(description);
			Calendar deadline = processDate(deadlineString, ATTRIBUTE_DEADLINE);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			deadlineTask = new TaskDeadline(description, location, deadline, tags);

		} catch (ParseException e) {
			logger_.log(Level.WARNING, LOGGER_READ_ERROR_DEADLINE);
		}
		return deadlineTask;
	}

	/**
	 * Processes the information read to create and return a TaskEvent.
	 * 
	 * @param description     The description of the TaskEvent.
	 * @param startDateString The start date of the TaskEvent as a String.
	 * @param endDateString   The end date of the TaskEvent as a String.
	 * @param location        The location of the TaskEvent.
	 * @param tagsString      The tags of the TaskEvent as a String.
	 * @return                A TaskEvent.
	 * @throws IOException    If I/O operations fail.
	 */
	private TaskEvent processEventTask(String description, String startDateString, String endDateString,
			String location, String tagsString) throws IOException {
		TaskEvent eventTask = null;
		try {
			description = processDescription(description);
			Calendar startDate = processDate(startDateString, ATTRIBUTE_START_DATE);
			Calendar endDate = processDate(endDateString, ATTRIBUTE_END_DATE);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			eventTask = new TaskEvent(description, location, startDate, endDate, tags);

		} catch (ParseException e) {
			logger_.log(Level.WARNING, LOGGER_READ_ERROR_EVENT);
		}
		return eventTask;
	}

	/**
	 * Processes the information read to create and return a TaskReserved.
	 * 
	 * @param description      The description of the TaskReserved.
	 * @param startDatesString The start dates of the TaskReserved as a String.
	 * @param endDatesString   The end dates of the TaskReserved as a String.
	 * @param location         The location of the TaskReserved.
	 * @param tagsString       The tags of the TaskReserved as a String.
	 * @return                 A TsakReserved.
	 * @throws IOException     If I/O operations fail.
	 */
	private TaskReserved processReservedTask(String description, String startDatesString, String endDatesString,
			String location, String tagsString) throws IOException {
		TaskReserved reservedTask = null;
		try {
			description = processDescription(description);
			ArrayList<Calendar> startDates = processDates(startDatesString, ATTRIBUTE_START_DATES);
			ArrayList<Calendar> endDates = processDates(endDatesString, ATTRIBUTE_END_DATES);
			location = processLocation(location);
			ArrayList<String> tags = processTags(tagsString);

			reservedTask = new TaskReserved(description, location, startDates, endDates, tags);

		} catch (ParseException e) {
			logger_.log(Level.WARNING, LOGGER_READ_ERROR_RESERVED);
		}
		return reservedTask;
	}

	/**
	 * Processes and removes the header from a line containing a tasks's description.
	 * 
	 * @param description The line containing a task's description.
	 * @return            The description of a task.
	 */
	private String processDescription(String description) {
		if (description.startsWith(ATTRIBUTE_DESCRIPTION)) {
			description = description.replaceFirst(ATTRIBUTE_DESCRIPTION, "").trim();
			if (description.isEmpty()) {
				description = EMPTY_DESCRIPTION;
			}
		}
		return description;
	}

	/**
	 * Processes and removes the header from a line containing a tasks's location.
	 * 
	 * @param location The line containing a task's location.
	 * @return         The location of a task.
	 */
	private String processLocation(String location) {
		if (isCompletedFloatingTask(location)) {
			location = location.replaceFirst(ATTRIBUTE_LOCATION, "").trim();
			if (location.isEmpty()) {
				location = null;
			}
		}
		return location;
	}

	/**
	 * Processes and removes the header from a line containing a task's tags.
	 * 
	 * @param tagsString A task's tags as a String.
	 * @return           A task's tags as an ArrayList.
	 */
	private ArrayList<String> processTags(String tagsString) {
		ArrayList<String> tags = null;
		if (tagsString.startsWith(ATTRIBUTE_TAGS)) {
			tags = new ArrayList<String>(Arrays.asList(tagsString.trim().split("\\s*#\\s*")));
			tags.remove(0);
		}
		return tags;
	}

	/**
	 * Processes and removes the header from a line containing a task's date.
	 * @param dateString      A task's date as a String.
	 * @param dateType        The type of date being processed (deadline, start date, or end date).
	 * @return                The date used in the Task as a Calendar.
	 * @throws ParseException If the Calendar is unable to parse the date in the text file.
	 */
	private Calendar processDate(String dateString, String dateType) throws ParseException {
		Calendar date = null;
		if (dateString.startsWith(dateType)) {
			date = Calendar.getInstance();
			date.setTime(sdf_.parse(dateString.replaceFirst(dateType, "").trim()));
		}
		return date;
	}

	/**
	 * Processes and removes the header from a line containing a reserved task's dates.
	 * 
	 * @param datesString     The dates of a reserved task as a String.
	 * @param dateType        The type of dates being processed (start dates or end dates).
	 * @return                The dates of the reserved task as a Calendar.
	 * @throws ParseException If the Calendar is unable to parse the date in the text file.
	 */
	private ArrayList<Calendar> processDates(String datesString, String dateType) throws ParseException {
		ArrayList<Calendar> dates = new ArrayList<Calendar>();

		if (datesString.startsWith(dateType)) {
			ArrayList<String> datesList = new ArrayList<String>(
					Arrays.asList(datesString.replaceFirst(dateType, "").trim().split("\\s*,\\s*")));

			for (String dateString : datesList) {
				Calendar date = Calendar.getInstance();
				date.setTime(sdf_.parse(dateString));
				dates.add(date);
			}
		}
		return dates;
	}

	/**
	 * Adds the TaskFloat to the ArrayList of TaskFloats if it is not null.
	 * 
	 * @param floatTasks The ArrayList of TaskFloats.
	 * @param floatTask  A TaskFloat.
	 */
	private void addFloatingTaskToList(ArrayList<TaskFloat> floatTasks, TaskFloat floatTask) {
		if (floatTask != null) {
			floatTasks.add(floatTask);
			logger_.log(Level.INFO, String.format(LOGGER_READ_FLOATING, floatTask.getDescription()));
		}
	}

	/**
	 * Adds a TaskDeadline to the ArrayList of TaskDeadlines if it is not null.
	 * 
	 * @param deadlineTasks The ArrayList of TaskDeadlines.
	 * @param deadlineTask  A TaskDeadline.
	 */
	private void addDeadlineTaskToList(ArrayList<TaskDeadline> deadlineTasks, TaskDeadline deadlineTask) {
		if (deadlineTask != null) {
			deadlineTasks.add(deadlineTask);
			logger_.log(Level.INFO, String.format(LOGGER_READ_DEADLINE, deadlineTask.getDescription()));
		}
	}

	/**
	 * Adds a TaskEvent to the ArrayList of TaskEvents if it is not null.
	 * 
	 * @param events    The ArrayList of TaskEvents.
	 * @param eventTask A TaskEvent.
	 */
	private void addEventTaskToList(ArrayList<TaskEvent> events, TaskEvent eventTask) {
		if (eventTask != null) {
			events.add(eventTask);
			logger_.log(Level.INFO, String.format(LOGGER_READ_EVENT, eventTask.getDescription()));
		}
	}

	/**
	 * Adds a TaskReserved to the ArrayList of TaskReserveds if it is not null.
	 * 
	 * @param reservedTasks The ArrayList of TaskReserveds.
	 * @param reservedTask  A TaskReserved.
	 */
	private void addReservedTaskToList(ArrayList<TaskReserved> reservedTasks, TaskReserved reservedTask) {
		if (reservedTask != null) {
			reservedTasks.add(reservedTask);
			logger_.log(Level.INFO, String.format(LOGGER_READ_RESERVED, reservedTask.getDescription()));
		}
	}

	/**
	 * Adds a completed Task if to the ArrayList of completed Tasks if it is not null.
	 * @param completedTasks The ArrayList of completed Tasks.
	 * @param task           A completed Task.
	 */
	private void addCompletedTaskToList(ArrayList<Task> completedTasks, Task task) {
		if (task != null) {
			completedTasks.add(task);
			logger_.log(Level.INFO, String.format(LOGGER_READ_COMPLETED, task.getDescription()));
		}
	}

	/**
	 * Reads the header of storage's text file.
	 * @param br           A BufferedReader that reads the text file. 
	 * @throws IOException If I/O operations fail.
	 */
	private void readHeader(BufferedReader br) throws IOException {
		br.readLine();
		br.readLine();
	}

	/**
	 * Checks to see if a line is invalid denoted by a null line or a divider.
	 * 
	 * @param line The line just read from the text file.
	 * @return     True if the line is invalid. False, otherwise.
	 */
	private boolean isInvalidLine(String line) {
		return line == null || line.equals(HEADER_DIVIDER);
	}

	/**
	 * Closes the BufferedReader.
	 * 
	 * @param br           The BufferedReader that read the text file.
	 * @throws IOException If I/O operations.
	 */
	private void closeReaderClasses(BufferedReader br) throws IOException {
		br.close();
	}

	/**
	 * Sets the global filePath variable to remember where the storage file is.
	 * @param filepath The file path of storage's text file.
	 */
	private void setFilePath(String filepath) {
		filePath_ = filepath;
	}

	/**
	 * Saves the given display into storage's text file.
	 * 
	 * @param thisDisplay  A Display containing all of a user's tasks.
	 * @throws IOException If I/O operations fail.
	 */
	public void saveFile(Display thisDisplay) throws IOException {
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath_)));

		ArrayList<TaskFloat> floatTasks = thisDisplay.getFloatTasks();
		ArrayList<TaskDeadline> deadlineTasks = thisDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> events = thisDisplay.getEventTasks();
		ArrayList<TaskReserved> reservedTasks = thisDisplay.getReservedTasks();
		ArrayList<Task> completedTasks = thisDisplay.getCompletedTasks();

		writeFloatingTasks(bw, floatTasks);
		writeDeadlineTasks(bw, deadlineTasks);
		writeEventTasks(bw, events);
		writeReservedTasks(bw, reservedTasks);
		writeCompletedTasks(bw, completedTasks);

		closeWriterClasses(bw);
	}

	/**
	 * Writes a header denoting the types of tasks into the text file.
	 * 
	 * @param bw           The BufferedWriter that writes to the text file.
	 * @param header       The header containing the type of tasks.
	 * @throws IOException If I/O operations fail.
	 */
	private void writeHeaderToFile(BufferedWriter bw, String header) throws IOException {
		bw.write(HEADER_DIVIDER);
		bw.newLine();
		bw.write(header);
		bw.newLine();
		bw.write(HEADER_DIVIDER);
		bw.newLine();
		bw.newLine();
	}

	/**
	 * Write the user's TaskFloats to storage's text file.
	 * 
	 * @param bw           The BufferedWriter that writes to the text file.
	 * @param floatTasks   An ArrayList of user's TaskFloats.
	 * @throws IOException If I/O operations fail.
	 */
	private void writeFloatingTasks(BufferedWriter bw, ArrayList<TaskFloat> floatTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_FLOATING);
		for (TaskFloat task : floatTasks) {
			bw.write(task.toString());
			logger_.log(Level.INFO, String.format(LOGGER_WRITE_FLOATING, task.getDescription()));
		}
	}

	/**
	 * Write the user's TaskDeadlines to storage's text file.
	 * 
	 * @param bw            The BufferedWriter that writes to the text file.
	 * @param deadlineTasks An ArrayList of user's TaskDeadlines.
	 * @throws IOException  If I/O operations fail.
	 */
	private void writeDeadlineTasks(BufferedWriter bw, ArrayList<TaskDeadline> deadlineTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_DEADLINE);
		for (TaskDeadline task : deadlineTasks) {
			bw.write(task.toString());
			logger_.log(Level.INFO, String.format(LOGGER_WRITE_DEADLINE, task.getDescription()));
		}
	}

	/**
	 * Write the user's TaskEvents to storage's text file.
	 * 
	 * @param bw           The BufferedWriter that writes to the text file.
	 * @param events       An ArrayList of user's TaskEvents.
	 * @throws IOException If I/O operations fail.
	 */
	private void writeEventTasks(BufferedWriter bw, ArrayList<TaskEvent> events) throws IOException {
		writeHeaderToFile(bw, HEADER_EVENT);
		for (TaskEvent event : events) {
			bw.write(event.toString());
			logger_.log(Level.INFO, String.format(LOGGER_WRITE_EVENT, event.getDescription()));
		}
	}

	/**
	 * Write the user's TaskReserveds to storage's text file.
	 * 
	 * @param bw            The BufferedWriter that writes to the text file.
	 * @param reservedTasks An ArrayList of user's TaskReserveds.
	 * @throws IOException  If I/O operations fail.
	 */
	private void writeReservedTasks(BufferedWriter bw, ArrayList<TaskReserved> reservedTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_RESERVED);
		for (TaskReserved task : reservedTasks) {
			bw.write(task.toString());
			logger_.log(Level.INFO, String.format(LOGGER_WRITE_RESERVED, task.getDescription()));
		}
	}

	/**
	 * Write the user's completed Tasks to storage's text file.
	 * 
	 * @param bw            The BufferedWriter that writes to the text file.
	 * @param deadlineTasks An ArrayList of user's completed Tasks.
	 * @throws IOException  If I/O operations fail.
	 */
	private void writeCompletedTasks(BufferedWriter bw, ArrayList<Task> completedTasks) throws IOException {
		writeHeaderToFile(bw, HEADER_COMPLETED);
		for (Task task : completedTasks) {
			bw.write(task.toString());
			logger_.log(Level.INFO, String.format(LOGGER_WRITE_COMPLETED, task.getDescription()));
		}
	}

	/**
	 * Flushes and closes the BufferedWriter.
	 *  
	 * @param bw           The BufferedWriter that wrote to the text file.
	 * @throws IOException If I/O operations fail.
	 */
	private void closeWriterClasses(BufferedWriter bw) throws IOException {
		bw.flush();
		bw.close();
	}

}
```
###### CS2103\src\tests\InputSuggestionTest.java
``` java
package tests;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import parser.InputSuggestion;

public class InputSuggestionTest {

	InputSuggestion inputSuggester = InputSuggestion.getInstance();

	/* Partition for commands that start with "d" */
	@Test
	public void deleteAndDoneTest() {
		String actual = inputSuggester.getSuggestedInput("d");
		String expected = "del/delete <task number(s)> // done <task number(s)>";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "del" */
	@Test
	public void deleteTest() {
		String actual = inputSuggester.getSuggestedInput("de");
		String expected = "del/delete <task number(s)>";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "do" */
	@Test
	public void doneTest() {
		String actual = inputSuggester.getSuggestedInput("do");
		String expected = "done <task number(s)>";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "u" */
	@Test
	public void undoUndoneAndUpdateTest() {
		String actual = inputSuggester.getSuggestedInput("u");
		String expected = "update <task number> // undo // undone <task number(s)>";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "un" */
	@Test
	public void undoAndUndoneTest() {
		String actual1 = inputSuggester.getSuggestedInput("un");
		String actual2 = inputSuggester.getSuggestedInput("undo");
		String expected = "undo // undone <task number(s)>";
		assertEquals(actual1, actual2, expected);
	}

	/* Partition for commands that start with "up" */
	@Test
	public void updateTest() {
		String actual = inputSuggester.getSuggestedInput("up");
		String expected = "update <task number> [description] [(-/+)time-group time(s)] [(-)@location] [(-)#tag]";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "re" */
	@Test
	public void redoAndReserveTest() {
		String actual1 = inputSuggester.getSuggestedInput("r");
		String actual2 = inputSuggester.getSuggestedInput("re");
		String expected = "redo // res/reserve <description> <from start date(s) to end date(s)>";
		assertEquals(actual1, actual2, expected);
	}

	/* Partition for commands that start with "red" */
	@Test
	public void redoTest() {
		String actual = inputSuggester.getSuggestedInput("red");
		String expected = "redo";
		assertEquals(actual, expected);
	}

	/* Partition for commands that start with "res" */
	@Test
	public void reserveTest() {
		String actual = inputSuggester.getSuggestedInput("res");
		String expected = "res/reserve <description> <from start date(s) to end date(s)>";
		assertEquals(actual, expected);
	}

}
```
###### CS2103\src\tests\IntegrationTest.java
``` java
package tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import entity.Display;
import logic.Logic;

public class IntegrationTest {

	private Display display;
	private String filepath = "src\\tests\\integrationTest.txt";

	@Before
	public void createTestFile() {
		Logic.createFile(filepath);
		Logic.initializeProgram(filepath);
	}

	@After
	public void deleteTestFile() {
		File testFile = new File(filepath);
		testFile.delete();
	}

	/**************************
	 * Input Validation Tests *
	 **************************/

	@Test
	public void testInvalidCommand() {
		display = Logic.executeUserCommand("This is an invalid command.");
		String expected = "You have specified an invalid command";
		String actual = display.getMessage();
		assertEquals(expected, actual);
	}

	@Test
	public void testEmptyCommand() {
		display = Logic.executeUserCommand("");
		String expected = "You have specified an invalid command";
		String actual = display.getMessage();
		assertEquals(expected, actual);
	}

	/**********************
	 * Adding Tasks Tests *
	 **********************/

	@Test
	public void testAddFloating() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		String expected = "added: \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testAddDeadline() {
		display = Logic.executeUserCommand("add Deadline Test due 14th Apr 3pm @NUS #tag");
		String expected = "added: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: Deadline Test\r\n"
				+ "Deadline: 14/04/16 15:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testAddDeadlineWithoutTime() {
		display = Logic.executeUserCommand("add Deadline Test due 14th Apr @NUS #tag");
		String expected = "added: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: Deadline Test\r\n"
		        + "Deadline: 14/04/16 23:59\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testAddEvent() {
		display = Logic.executeUserCommand("add Event Test from 14th Apr 3pm to 4pm @NUS #tag");
		String expected = "added: \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=["
		        + "Description: Event Test\r\n"
		        + "Start Date: 14/04/16 15:00\r\n"
		        + "End Date: 14/04/16 16:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testAddEmpty() {
		display = Logic.executeUserCommand("add");
		String expected = "Please enter a description";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertEquals("Display [message=Please enter a description, events=[], deadlineTasks=[], "
				+ "floatTasks=[], reservedTasks=[], completedTasks=[]]", display.toString());
	}

	/************************
	 * Updating Tasks Tests *
	 ************************/

	@Test
	public void testUpdateFloatingDescription() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 New Description");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: New Description\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateFloatingLocation() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 @newPlace");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: newPlace\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateFloatingTags() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("update 1 -#tag #newTag");
		String expected = "Edited : \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #newTag\r\n\r\n]"));
	}

	@Test
	public void testUpdateDeadlineDescription() {
		display = Logic.executeUserCommand("add Deadline Test due April 11 @NUS #tag");
		display = Logic.executeUserCommand("update 1 New Description");
		String expected = "Edited : \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: New Description\r\n"
		        + "Deadline: 11/04/16 23:59\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateDeadlineTime() {
		display = Logic.executeUserCommand("add Deadline Test due tomorrow @NUS #tag");
		display = Logic.executeUserCommand("update 1 +end 15th Apr 4pm");
		String expected = "Edited : \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks="
		        + "[Description: Deadline Test\r\n"
		        + "Deadline: 15/04/16 16:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateEventStartTime() {
		display = Logic.executeUserCommand("add Event Test from 14th Apr 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 +start 14th Apr 12pm");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=["
		        + "Description: Event Test\r\n"
		        + "Start Date: 14/04/16 12:00"
		        + "\r\nEnd Date: 14/04/16 16:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateEventEndTime() {
		display = Logic.executeUserCommand("add Event Test from 14th Apr 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 +end 14th Apr 7pm");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=["
		        + "Description: Event Test\r\n"
		        + "Start Date: 14/04/16 15:00\r\n"
		        + "End Date: 14/04/16 19:00\r\nLocation: NUS\r\nTags: #tag\r\n\r\n]"));
	}

	@Test
	public void testUpdateEventTimes() {
		display = Logic.executeUserCommand("add Event Test from 14th Apr 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("update 1 +both 13th Apr 9 pm to 14th Apr 10am");
		String expected = "Edited : \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=["
		        + "Description: Event Test\r\n"
		        + "Start Date: 13/04/16 21:00\r\n"
		        + "End Date: 14/04/16 10:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	/************************
	 * Deleting Tasks Tests *
	 ************************/

	@Test
	public void testDeleteFloating() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=[]"));
	}

	@Test
	public void testDeleteDeadline() {
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Deadline Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=[]"));
	}

	@Test
	public void testDeleteEvent() {
		display = Logic.executeUserCommand("add Event Test from tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1");
		String expected = "deleted: \"Event Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=[]"));
	}

	@Test
	public void testDeleteAll() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("add Event Test tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete all");
		String expected = "All tasks deleted";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString()
				.contains("events=[], deadlineTasks=[], floatTasks=[], "
		        + "reservedTasks=[], completedTasks=[]]"));
	}

	@Test
	public void testDeleteMultiple() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("add Deadline Test due tomorrow 3pm @NUS #tag");
		display = Logic.executeUserCommand("add Event Test from tomorrow 3pm to 4pm @NUS #tag");
		display = Logic.executeUserCommand("delete 1,2,3");
		String expected = "deleted: \"Deadline Test\", \"Event Test\", \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString()
				.contains("events=[], deadlineTasks=[], floatTasks=[], "
		        + "reservedTasks=[], completedTasks=[]]"));
	}

	@Test
	public void testDeleteInvalidTaskNumber() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("delete 5");
		String expected = "You have specified invalid numbers: 5";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	/*************************
	 * Reserving Tasks Tests *
	 *************************/

	@Test
	public void testReserveSingle() {
		display = Logic.executeUserCommand("reserve Reservation Test from 14th Apr 3pm to 4pm @NUS #tag");
		String expected = "Reserved: \"Reservation Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("reservedTasks=["
		        + "Description: Reservation Test\r\n"
		        + "Start Dates: 14/04/16 15:00\r\n"
		        + "End Dates: 14/04/16 16:00\r\n"
				+ "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testReserveDouble() {
		display = Logic.executeUserCommand(
				"reserve Reservation Test from 14th Apr 3pm to 4pm and 15th Apr 4pm to 6pm @NUS #tag");
		String expected = "Reserved: \"Reservation Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("reservedTasks=["
		        + "Description: Reservation Test\r\n"
	        	+ "Start Dates: 14/04/16 15:00, 15/04/16 16:00\r\n"
				+ "End Dates: 14/04/16 16:00, 15/04/16 18:00\r\n"
		        + "Location: NUS\r\nTags: #tag\r\n\r\n]"));
	}

	/***********************
	 * Undo and Redo Tests *
	 ***********************/

	@Test
	public void testUndo() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("undo");
		String expected = "Undid previous commands";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=[]"));
	}

	@Test
	public void testRedo() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("undo");
		display = Logic.executeUserCommand("redo");
		String expected = "Redid command(s)";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
	         	+ "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testRedoError() {
		display = Logic.executeUserCommand("redo");
		String expected = "You have reached the latest point possible";
		String actual = display.getMessage();

		assertEquals(expected, actual);
	}

	/******************************
	 * Mark Done and Undone Tests *
	 ******************************/

	@Test
	public void testMarkDone() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		String expected = "Completed: \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString()
				.contains("events=[], deadlineTasks=[], floatTasks=[], "
		        + "reservedTasks=[], completedTasks=[]"));
	}

	@Test
	public void testMarkDoneInvalidNumber() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 10");
		String expected = "You have specified invalid task numbers: 10";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testMarkUnDone() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		display = Logic.executeUserCommand("show /done");
		display = Logic.executeUserCommand("undone 1");
		String expected = "Undone task: \"Floating Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("floatTasks=["
		        + "Description: Floating Test\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testMarkUnDoneInvalidNumber() {
		display = Logic.executeUserCommand("add Floating Test @NUS #tag");
		display = Logic.executeUserCommand("done 1");
		display = Logic.executeUserCommand("show Test");
		display = Logic.executeUserCommand("undone 10");
		String expected = "You have specified invalid task numbers: 10";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString()
				.contains("events=[], deadlineTasks=[], floatTasks=[], "
		        + "reservedTasks=[], completedTasks=[]"));
	}

	/*****************
	 * Confirm Tests *
	 *****************/

	@Test
	public void testConfirmReservation() {
		display = Logic.executeUserCommand(
				"reserve Reservation Test from 14th Apr 3pm to 4pm and 15th Apr 4pm to 6pm @NUS #tag");
		display = Logic.executeUserCommand("confirm 1 1");
		String expected = "added: \"Reservation Test\"";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("events=["
		        + "Description: Reservation Test\r\n"
		        + "Start Date: 14/04/16 15:00\r\n"
		        + "End Date: 14/04/16 16:00\r\n"
				+ "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testConfirmInvalidReservation() {
		display = Logic.executeUserCommand(
				"reserve Reservation Test from 14th Apr 3pm to 4pm and 15th Apr 4pm to 6pm @NUS #tag");
		display = Logic.executeUserCommand("confirm 2 2");
		String expected = "Please specify a valid index";
		String actual = display.getMessage();

		assertEquals(expected, actual);
	}

	/*****************
	 * Postpone Tests *
	 *****************/

	@Test
	public void testPostponeHours() {
		display = Logic.executeUserCommand("add Deadline Test due 14th Apr 3pm @NUS #tag");
		display = Logic.executeUserCommand("postpone 1 2hours");
		String expected = "Postponed: Deadline Test";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: Deadline Test\r\n"
	        	+ "Deadline: 14/04/16 17:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testPostponeDays() {
		display = Logic.executeUserCommand("add Deadline Test due 14th Apr 3pm @NUS #tag");
		display = Logic.executeUserCommand("postpone 1 2days");
		String expected = "Postponed: Deadline Test";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: Deadline Test\r\n"
		        + "Deadline: 16/04/16 15:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}

	@Test
	public void testPostponeInvalid() {
		display = Logic.executeUserCommand("add Deadline Test due 14th Apr 3pm @NUS #tag");
		display = Logic.executeUserCommand("postpone 3 2days");
		String expected = "You can only pospone deadline tasks and events!";
		String actual = display.getMessage();

		assertEquals(expected, actual);
		assertTrue(display.toString().contains("deadlineTasks=["
		        + "Description: Deadline Test\r\n"
		        + "Deadline: 14/04/16 15:00\r\n"
		        + "Location: NUS\r\n"
		        + "Tags: #tag\r\n\r\n]"));
	}
}
```
###### CS2103\src\tests\StorageTest.java
``` java

package tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import entity.Display;
import entity.Task;
import entity.TaskDeadline;
import entity.TaskEvent;
import entity.TaskFloat;
import entity.TaskReserved;
import storage.Storage;

public class StorageTest {

	private static final String FILE_TEST = "src\\tests\\storageTests\\test.txt";
	private static final String FILE_TEST_INVALID = "src\\storageTests\\test.txt";
	private static final String FILE_TEST_EMPTY_DESCRIPTION = "src\\tests\\storageTests\\emptyDescriptionTest.txt";
	private static final String FILE_TEST_EMPTY_LOCATION = "src\\tests\\storageTests\\emptyLocationTest.txt";
	private static final String FILE_TEST_EMPTY_TAGS = "src\\tests\\storageTests\\emptyTagsTest.txt";
	private static final String FILE_TEST_EMPTY_DEADLINE = "src\\tests\\storageTests\\emptyDeadlineTest.txt";
	private static final String FILE_TEST_EMPTY_DATES = "src\\tests\\storageTests\\emptyDatesTest.txt";

	private Storage storage = Storage.getInstance();
	private Display display;

	/* Creates a display to be used for the unit tests */
	@Before
	public void setUpDisplay() {
		ArrayList<String> tags = new ArrayList<>(Arrays.asList("tag1, tag2"));
		Calendar date = Calendar.getInstance();

		TaskFloat floatTask = new TaskFloat("Test Floating", "NUS", tags);
		TaskDeadline deadlineTask = new TaskDeadline("Test Deadline", "NUS", date, tags);
		TaskEvent eventTask = new TaskEvent("Test Event", "NUS", date, date, tags);

		ArrayList<TaskFloat> floatTasks = new ArrayList<TaskFloat>();
		ArrayList<TaskDeadline> deadlineTasks = new ArrayList<TaskDeadline>();
		ArrayList<TaskEvent> eventTasks = new ArrayList<TaskEvent>();
		ArrayList<TaskReserved> reservedTasks = new ArrayList<TaskReserved>();
		ArrayList<Task> completedTasks = new ArrayList<Task>();

		floatTasks.add(floatTask);
		floatTasks.add(floatTask);

		deadlineTasks.add(deadlineTask);
		deadlineTasks.add(deadlineTask);

		eventTasks.add(eventTask);
		eventTasks.add(eventTask);

		display = new Display("", eventTasks, deadlineTasks, floatTasks, reservedTasks, completedTasks);
	}

	@Before
	public void prepareTextFileForTests() throws IOException {
		storage.createFile(FILE_TEST);
	}

	/* This is a case for the successful createFile() partition */
	@Test
	public void testfileExists() {
		File file = new File(FILE_TEST);
		assertTrue(file.exists());
	}

	/*
	 * This is a case for the createFile() partition proving that it creates a
	 * file in the correct location
	 */
	@Test
	public void testfileLocation() {
		File file = new File(FILE_TEST_INVALID);
		assertFalse(file.exists());
	}

	/* This is a case for the normal reading from file partition */
	@Test
	public void testSaveAndRead() throws IOException {
		storage.saveFile(display);
		assertEquals(display.toString(), storage.getDisplay(FILE_TEST).toString());
	}

	/*
	 * This is a case for the reading from a file with empty descriptions
	 * partition
	 */
	@Test
	public void testReadEmptyDescription() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay(FILE_TEST_EMPTY_DESCRIPTION);

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		assertEquals("undefined", emptyFloat.get(0).getDescription());
		assertEquals("undefined", emptyDeadline.get(0).getDescription());
		assertEquals("undefined", emptyEvent.get(0).getDescription());
	}

	/*
	 * This is a case for the reading from a file with empty locations partition
	 */
	@Test
	public void testReadEmptyLocation() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay(FILE_TEST_EMPTY_LOCATION);

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		assertEquals(null, emptyFloat.get(0).getLocation());
		assertEquals(null, emptyDeadline.get(0).getLocation());
		assertEquals(null, emptyEvent.get(0).getLocation());
	}

	/* This is a case for the reading from a file with empty tags partition */
	@Test
	public void testReadEmptyTags() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay(FILE_TEST_EMPTY_TAGS);

		ArrayList<TaskFloat> emptyFloat = emptyDescriptionDisplay.getFloatTasks();
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();

		ArrayList<Task> emptyTagList = new ArrayList<Task>();

		assertEquals(emptyTagList, emptyFloat.get(0).getTags());
		assertEquals(emptyTagList, emptyDeadline.get(0).getTags());
		assertEquals(emptyTagList, emptyEvent.get(0).getTags());
	}

	/*
	 * This is a case for the reading from a file with empty deadlines partition
	 */
	@Test
	public void testReadEmptyDeadline() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay(FILE_TEST_EMPTY_DEADLINE);
		ArrayList<TaskDeadline> emptyDeadline = emptyDescriptionDisplay.getDeadlineTasks();
		assertTrue(emptyDeadline.isEmpty());
	}

	/* This is a case for the reading from a file with empty dates partition */
	@Test
	public void testReadEmptyDates() throws IOException {
		Display emptyDescriptionDisplay = storage.getDisplay(FILE_TEST_EMPTY_DATES);
		ArrayList<TaskEvent> emptyEvent = emptyDescriptionDisplay.getEventTasks();
		assertTrue(emptyEvent.isEmpty());
	}

	@After
	public void closeDownAfterTests() {
		File file = new File(FILE_TEST);
		file.delete();
	}

}
```
